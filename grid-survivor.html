<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Survivor - Sopravvivi alla Griglia!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            position: relative;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 6px;
            font-size: 1.6em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .subtitle {
            display: none;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr) auto;
            gap: 8px;
            margin-bottom: 4px;
            align-items: stretch;
        }

        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 4px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .stat-label {
            font-size: 0.7em;
            opacity: 0.9;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        /* VITE ‚Äî colonna 4 degli stat, allineate verticalmente al centro */
        .lives-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 3px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 6px 8px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .life-heart {
            font-size: 1.1em;
            line-height: 1;
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8));
        }
        .life-heart.lost {
            animation: heartLost 0.5s ease forwards;
        }
        @keyframes heartLost {
            0%   { transform: scale(1); }
            25%  { transform: scale(1.3) rotate(-12deg); }
            50%  { transform: scale(0.8) rotate(8deg); }
            100% { transform: scale(1); opacity: 0.35; }
        }

        /* SHIELD BADGE */
        .shield-badge {
            display: none;
            position: absolute;
            top: 6px;
            right: 14px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            font-size: 0.75em;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(59,130,246,0.45);
            animation: shieldBadgePulse 1.8s ease infinite;
            white-space: nowrap;
            z-index: 10;
        }
        .shield-badge.show { display: block; }
        @keyframes shieldBadgePulse {
            0%, 100% { box-shadow: 0 2px 8px rgba(59,130,246,0.45); }
            50%      { box-shadow: 0 2px 14px rgba(59,130,246,0.75); }
        }

        /* SOUND TOGGLE */
        .sound-toggle {
            position: absolute;
            top: 6px;
            left: 14px;
            font-size: 1.5em;
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s ease, opacity 0.2s ease;
            z-index: 10;
            opacity: 0.7;
        }
        .sound-toggle:hover {
            transform: scale(1.15);
            opacity: 1;
        }

        /* TIMER SUL PERIMETRO DELLA GRIGLIA */
        .grid-wrap {
            position: relative;
            margin-bottom: 10px;
        }
        .timer-perimeter {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            overflow: visible;
            opacity: 0; /* Nascosto fino a startTimer */
            transition: opacity 0.3s ease;
        }
        .timer-perimeter.active {
            opacity: 1;
        }
        .timer-perimeter rect {
            fill: none;
            stroke: #4ade80;
            stroke-width: 6;
            transition: stroke-dashoffset 0.1s linear;
            filter: drop-shadow(0 0 4px rgba(74,222,128,0.5));
        }
        .timer-perimeter.warning rect {
            stroke: #fbbf24;
            filter: drop-shadow(0 0 5px rgba(251,191,36,0.6));
        }
        .timer-perimeter.danger rect {
            stroke: #ef4444;
            filter: drop-shadow(0 0 7px rgba(239,68,68,0.75));
            animation: perimPulse 0.5s infinite;
        }
        @keyframes perimPulse {
            0%, 100% { opacity: 1; }
            50%      { opacity: 0.45; }
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            aspect-ratio: 1;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .grid-cell {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            border: 2px solid #ccc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .grid-cell:hover:not(.eliminated):not(.selected) {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            border-color: #667eea;
        }

        .grid-cell.selected {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #1d4ed8;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.5);
        }

        .grid-cell.revealed {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border-color: #b91c1c;
            color: white;
            animation: reveal 0.5s ease;
        }

        .grid-cell.eliminated {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-color: #047857;
            color: white;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .grid-cell.eliminated::after {
            content: '‚úì';
            position: absolute;
            font-size: 1.5em;
            color: white;
        }

        .grid-cell.bonus-preview {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            border-color: #f59e0b !important;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.8) !important;
            animation: bonusGlow 0.6s ease-in-out infinite;
            font-size: 1.8em !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        @keyframes bonusGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.8); }
            50%      { box-shadow: 0 0 35px rgba(251, 191, 36, 1); }
        }

        @keyframes reveal {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .message {
            text-align: center;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 0.9em;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message.info {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }

        .message.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .message.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .combo-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            font-weight: bold;
            color: #f59e0b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            z-index: 5;
            white-space: nowrap;
            animation: bounce 0.5s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50%      { transform: translate(-50%, -50%) scale(1.2); }
        }

        .button-container {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            padding: 10px 18px;
            font-size: 0.9em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        button.primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button.secondary {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
        }

        button.secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(107, 114, 128, 0.4);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15) !important;
        }

        /* GAME OVER OVERLAY */
        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .game-over-overlay.show {
            display: flex;
        }

        .game-over-content {
            background: white;
            padding: 25px 20px;
            border-radius: 20px;
            text-align: center;
            max-width: 420px;
            width: 90%;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .game-over-content h2 {
            color: #ef4444;
            font-size: 2em;
            margin-bottom: 15px;
        }

        .final-stats {
            margin: 20px 0;
            font-size: 1.2em;
            color: #666;
        }

        .final-stats div {
            margin: 10px 0;
        }

        /* PARTICLES */
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #10b981;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFall 1s ease-out forwards;
        }

        @keyframes particleFall {
            to { transform: translateY(50px); opacity: 0; }
        }

        /* BONUS */
        .bonuses-container {
            display: flex;
            gap: 4px;
            justify-content: center; /* Default: centrati */
            margin-bottom: 6px;
            flex-wrap: nowrap;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 4px 2px;
            position: relative;
        }

        /* Quando scrollabile: allinea a sinistra e aggiungi gradient fade */
        .bonuses-container.scrollable {
            justify-content: flex-start;
            -webkit-mask-image: linear-gradient(to right, transparent 0%, black 20px, black calc(100% - 20px), transparent 100%);
            mask-image: linear-gradient(to right, transparent 0%, black 20px, black calc(100% - 20px), transparent 100%);
        }

        /* Scrollbar personalizzata per bonus */
        .bonuses-container::-webkit-scrollbar {
            height: 4px;
        }
        .bonuses-container::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
        }
        .bonuses-container::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 10px;
        }
        .bonuses-container::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        .bonus-card {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            padding: 4px 6px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(251, 191, 36, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
            min-width: 42px;
            max-width: 42px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border: 1.5px solid #fbbf24;
            flex-shrink: 0;
        }

        .bonus-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
        }

        .bonus-card.disabled {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            border-color: #4b5563;
            opacity: 0.75;
            cursor: not-allowed;
            box-shadow: 0 2px 6px rgba(107, 114, 128, 0.3);
        }
        .bonus-card.disabled .bonus-icon { filter: grayscale(100%) brightness(1.4); opacity: 0.85; }
        .bonus-card.disabled .bonus-name { color: #d1d5db; opacity: 1; }
        .bonus-card.disabled:hover {
            transform: none;
            box-shadow: 0 2px 6px rgba(107, 114, 128, 0.3);
        }

        .bonus-card.used {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%) !important;
            border-color: #4b5563 !important;
            opacity: 0.6;
            cursor: not-allowed !important;
            position: relative;
        }
        .bonus-card.used:hover {
            transform: none !important;
            box-shadow: 0 2px 6px rgba(107, 114, 128, 0.3) !important;
        }
        .bonus-card.used::after {
            content: '‚úñ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            color: #dc2626;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }

        /* REMOVED BONUS (Card Malus) */
        .bonus-card.removed {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%) !important;
            border: 2px solid #312e81 !important;
            opacity: 0.5;
            cursor: not-allowed !important;
            position: relative;
        }
        .bonus-card.removed:hover {
            transform: none !important;
            box-shadow: 0 2px 6px rgba(99, 102, 241, 0.3) !important;
        }
        .bonus-card.removed::after {
            content: 'üíÄ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        .bonus-card .bonus-icon { font-size: 1.1em; }
        .bonus-card .bonus-name { font-size: 0.55em; font-weight: bold; white-space: nowrap; }

        .bonus-notification {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 2em;
            font-weight: bold;
            z-index: 2000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: bonusPopup 0.5s ease;
            display: none;
            text-align: center;
        }

        .bonus-notification.show { display: block; }

        @keyframes bonusPopup {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* LIFELINE CELLS */
        .grid-cell.lifeline-active {
            background: linear-gradient(135deg, #fef08a 0%, #fde047 100%) !important;
            border-color: #ca8a04 !important;
            box-shadow: 0 0 14px rgba(250,204,21,0.7), inset 0 0 8px rgba(250,204,21,0.3) !important;
            animation: lifelinePulse 0.8s ease-in-out infinite !important;
        }
        @keyframes lifelinePulse {
            0%, 100% { box-shadow: 0 0 10px rgba(250,204,21,0.5), inset 0 0 6px rgba(250,204,21,0.2); }
            50%      { box-shadow: 0 0 22px rgba(250,204,21,0.85), inset 0 0 12px rgba(250,204,21,0.4); }
        }
        /* lifeline-survived: verde brillante, una delle 5 √® sopravvissuta */
        .grid-cell.lifeline-survived {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%) !important;
            border-color: #16a34a !important;
            box-shadow: 0 0 18px rgba(74,222,128,0.7) !important;
        }

        /* VISION SAFE CELLS */
        .grid-cell.vision-safe {
            border: 3px solid #10b981 !important;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.6), inset 0 0 10px rgba(16, 185, 129, 0.15) !important;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important;
        }

        /* MAGNET REVEAL */
        .grid-cell.magnet-reveal {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            border: 3px solid #f59e0b !important;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.8) !important;
            animation: magnetPulse 0.8s ease-in-out infinite;
            font-size: 1.5em !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        @keyframes magnetPulse {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 35px rgba(251, 191, 36, 1);
                transform: scale(1.05);
            }
        }

        /* HIT */
        .grid-cell.hit {
            border: 4px solid #ef4444 !important;
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%) !important;
            animation: hitPulse 0.5s ease-in-out 3;
        }

        @keyframes hitPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(239, 68, 68, 0.8); }
            50% { transform: scale(1.15); box-shadow: 0 0 40px rgba(239, 68, 68, 1); }
        }

        /* MONSTER POPUP */
        .monster-popup {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 3000;
            display: none;
            animation: monsterAppear 0.5s ease forwards;
        }

        .monster-popup.show { display: block; }

        @keyframes monsterAppear {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
            60% { transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }

        .monster-container {
            background: white;
            padding: 40px;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            border: 5px solid #ef4444;
        }

        .monster-emoji {
            font-size: 8em;
            margin-bottom: 20px;
            animation: monsterBounce 0.6s ease-in-out infinite;
        }

        @keyframes monsterBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .monster-text {
            font-size: 2.5em;
            font-weight: bold;
            color: #ef4444;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* MALUS POPUP */
        .malus-popup {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .malus-popup.show { display: flex; }

        .malus-container {
            background: linear-gradient(160deg, #1a0a0a 0%, #2d1010 50%, #1a0a0a 100%);
            border: 3px solid #7f1d1d;
            border-radius: 28px;
            padding: 40px 50px;
            text-align: center;
            box-shadow: 0 0 60px rgba(200, 30, 30, 0.5), 0 0 120px rgba(180, 20, 20, 0.25);
            animation: malusPulse 0.6s ease-in-out infinite alternate;
            max-width: 420px;
        }

        @keyframes malusPulse {
            from { box-shadow: 0 0 60px rgba(200, 30, 30, 0.5), 0 0 120px rgba(180, 20, 20, 0.25); }
            to   { box-shadow: 0 0 80px rgba(220, 40, 40, 0.7), 0 0 140px rgba(200, 30, 30, 0.35); }
        }

        .malus-emoji {
            font-size: 7em;
            display: block;
            animation: malusShake 0.3s ease-in-out infinite alternate;
        }

        @keyframes malusShake {
            from { transform: rotate(-4deg) scale(1); }
            to   { transform: rotate(4deg) scale(1.05); }
        }

        .malus-text {
            color: #fca5a5;
            font-size: 1.6em;
            font-weight: bold;
            margin-top: 12px;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
            line-height: 1.3;
        }

        .malus-text .malus-highlight {
            color: #f87171;
            font-size: 1.15em;
        }

        /* CARD MALUS POPUP */
        .card-malus-popup {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .card-malus-popup.show { display: flex; }

        .card-malus-container {
            background: linear-gradient(160deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);
            border: 3px solid #6366f1;
            border-radius: 28px;
            padding: 40px 30px;
            text-align: center;
            box-shadow: 0 0 60px rgba(99, 102, 241, 0.5), 0 0 120px rgba(79, 70, 229, 0.25);
            animation: cardMalusPulse 0.8s ease-in-out infinite alternate;
            max-width: 500px;
        }

        @keyframes cardMalusPulse {
            from { box-shadow: 0 0 60px rgba(99, 102, 241, 0.5), 0 0 120px rgba(79, 70, 229, 0.25); }
            to   { box-shadow: 0 0 80px rgba(129, 140, 248, 0.7), 0 0 140px rgba(99, 102, 241, 0.35); }
        }

        .card-malus-emoji {
            font-size: 5em;
            animation: cardFloat 2s ease-in-out infinite;
        }

        @keyframes cardFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .card-malus-title {
            color: #c7d2fe;
            font-size: 2.2em;
            font-weight: bold;
            margin: 15px 0 10px;
            text-shadow: 0 0 15px rgba(99, 102, 241, 0.8);
        }

        .card-malus-subtitle {
            color: #a5b4fc;
            font-size: 1.1em;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .cards-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .card {
            width: 100px;
            height: 140px;
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            border: 3px solid #818cf8;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.6);
        }

        .card-back {
            font-size: 3em;
            animation: cardPulse 1.5s ease-in-out infinite;
        }

        @keyframes cardPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .card.flipped {
            animation: cardFlip 0.6s ease;
        }

        @keyframes cardFlip {
            0% { transform: rotateY(0); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0); }
        }

        /* LEADERBOARD */
        .leaderboard-container {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            margin: 20px auto;
        }

        .leaderboard-container h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 5px 0;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            border-radius: 8px;
            align-items: center;
            font-size: 0.85em;
        }

        .leaderboard-entry.top1 {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white; 
            font-weight: bold; 
            font-size: 0.95em;
        }

        .leaderboard-entry.top2 {
            background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
            color: white;
        }

        .leaderboard-entry.top3 {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
        }

        /* Leaderboard list with scrolling */
        #leaderboard-list {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            margin: 15px 0;
            padding-right: 5px;
        }

        /* Scrollbar styling for leaderboard */
        #leaderboard-list::-webkit-scrollbar {
            width: 6px;
        }
        #leaderboard-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #leaderboard-list::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        /* USER ENTRY HIGHLIGHT */
        .leaderboard-entry.user-entry {
            animation: userEntryPulse 2s ease infinite;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
            border: 2px solid #667eea;
        }

        @keyframes userEntryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .new-badge {
            display: inline-block;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            font-weight: bold;
            animation: badgeBounce 1s ease infinite;
        }

        @keyframes badgeBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        /* NAME INPUT */
        .name-input-container {
            margin: 20px 0;
        }

        .name-input-container input {
            padding: 12px 20px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            border-radius: 10px;
            width: 250px;
            text-align: center;
        }

        .name-input-container input:focus {
            outline: none;
            border-color: #764ba2;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }

        /* EMOJI PICKER */
        .emoji-picker {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .emoji-option {
            font-size: 2em;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 12px;
            border: 3px solid transparent;
            background: #f3f4f6;
            transition: all 0.2s ease;
            user-select: none;
        }

        .emoji-option:hover {
            background: #e5e7eb;
            transform: scale(1.15);
        }

        .emoji-option.selected-emoji {
            border-color: #667eea;
            background: #eef2ff;
            box-shadow: 0 0 12px rgba(102, 126, 234, 0.4);
            transform: scale(1.1);
        }

        /* NOT IN TOP 10 message */
        .not-in-top {
            font-size: 1.1em;
            color: #666;
            margin: 15px 0;
            padding: 12px;
            background: #f3f4f6;
            border-radius: 10px;
        }

        /* VICTORY SCREEN */
        .victory-content {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            padding: 40px 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            animation: victoryBounce 0.8s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(251, 191, 36, 0.4);
        }

        @keyframes victoryBounce {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }

        .victory-confetti {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .victory-emoji {
            font-size: 5em;
            animation: victoryEmoji 1s ease infinite;
            margin-bottom: 10px;
        }

        @keyframes victoryEmoji {
            0%, 100% { transform: scale(1) rotate(-5deg); }
            50% { transform: scale(1.2) rotate(5deg); }
        }

        .victory-title {
            font-size: 3em;
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            margin: 10px 0;
            font-weight: bold;
            letter-spacing: 3px;
        }

        .victory-subtitle {
            font-size: 1.2em;
            color: #1f2937;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .victory-stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
        }

        .victory-stat {
            background: rgba(255,255,255,0.3);
            padding: 20px;
            border-radius: 15px;
            min-width: 120px;
            backdrop-filter: blur(10px);
        }

        .victory-stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .victory-stat-label {
            font-size: 0.9em;
            color: #1f2937;
            margin-top: 5px;
            font-weight: 600;
        }

        .victory-button {
            font-size: 1.2em !important;
            padding: 15px 40px !important;
            animation: victoryButtonPulse 2s ease infinite;
        }

        @keyframes victoryButtonPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
            50% { transform: scale(1.05); box-shadow: 0 6px 25px rgba(0,0,0,0.3); }
        }

    </style>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body>
    <div class="game-container">
        <h1>üéØ Grid Survivor</h1>
        <p class="subtitle">Scegli saggiamente e sopravvivi!</p>

        <!-- shield badge: appare nell'angolo in alto a destra quando scudo attivo -->
        <div class="shield-badge" id="shield-badge">üõ°Ô∏è SCUDO</div>

        <!-- sound toggle: angolo in alto a sinistra -->
        <div class="sound-toggle" id="sound-toggle" onclick="toggleSound()" title="Attiva/Disattiva Suoni">
            <span id="sound-icon">üîä</span>
        </div>

        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">Punteggio</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Caselle</div>
                <div class="stat-value" id="cells-eliminated">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Streak</div>
                <div class="stat-value" id="streak">0</div>
            </div>
            <div class="lives-container" id="lives"></div>
        </div>

        <div style="position: relative;">
            <div class="bonuses-container" id="bonuses"></div>
            <div id="bonus-scroll-hint" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                font-size: 0.8em;
                color: #1f2937;
                background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
                padding: 8px 16px;
                border-radius: 20px;
                box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
                display: none;
                pointer-events: none;
                z-index: 10;
                white-space: nowrap;
                font-weight: bold;
            ">
                üëà Scorri per vedere tutti üëâ
            </div>
        </div>

        <!-- Griglia + timer perimetrale + combo overlay -->
        <div class="grid-wrap" id="grid-wrap">
            <div class="grid-container" id="grid"></div>
            <div class="combo-indicator" id="combo"></div>
            <svg class="timer-perimeter" id="timer-perimeter">
                <rect id="timer-rect" x="3" y="3" width="100" height="100" rx="10" ry="10"/>
            </svg>
        </div>

        <div class="message info" id="message">Seleziona una casella per iniziare!</div>

        <div class="button-container">
            <button class="primary" id="start-btn" onclick="startGame()">Nuova Partita</button>
            <button class="secondary" id="reset-btn" onclick="startGame()" style="display: none;">Nuova Partita</button>
            <button class="secondary" onclick="showLeaderboard()" style="padding: 10px 16px; font-size: 0.85em;">üèÜ Classifica</button>
        </div>
    </div>

    <!-- GAME OVER -->
    <div class="game-over-overlay" id="game-over">
        <div class="game-over-content">
            <h2>üí• GAME OVER!</h2>
            <div class="final-stats">
                <div><strong>Punteggio Finale:</strong> <span id="final-score">0</span></div>
                <div><strong>Caselle Eliminate:</strong> <span id="final-cells">0</span></div>
                <div><strong>Miglior Streak:</strong> <span id="final-streak">0</span></div>
            </div>

            <!-- Sezione per chi entra nella classifica -->
            <div id="save-section">
                <div class="name-input-container">
                    <input type="text" id="player-name" placeholder="Inserisci il tuo nome" maxlength="20" oninput="onNameInput()">
                </div>
                <div class="emoji-picker" id="emoji-picker"></div>
                <button class="primary" id="save-btn" onclick="saveToLeaderboard()" disabled>Salva e Vedi Classifica</button>
            </div>

            <!-- Sezione per chi NON entra nella classifica -->
            <div id="no-save-section" style="display:none;">
                <div class="not-in-top">Non sei entrato nei primi 10. Riprova!</div>
                <button class="primary" onclick="closeGameOver()">Riprova</button>
            </div>
        </div>
    </div>

    <!-- LEADERBOARD -->
    <div class="game-over-overlay" id="leaderboard-overlay">
        <div class="game-over-content" style="max-width: 500px;">
            <h2>üèÜ CLASSIFICA</h2>
            <div id="firebase-status" style="font-size: 0.75em; color: #666; margin-bottom: 10px; text-align: center;"></div>
            <div id="leaderboard-list"></div>
            <button class="primary" onclick="closeLeaderboard()" style="width: 100%; max-width: 250px;">Gioca Ancora</button>
        </div>
    </div>

    <!-- VICTORY -->
    <div class="game-over-overlay" id="victory-overlay">
        <div class="victory-content">
            <div class="victory-confetti" id="victory-confetti"></div>
            <div class="victory-emoji">üéâ</div>
            <h1 class="victory-title">VITTORIA!</h1>
            <p class="victory-subtitle">Hai completato tutte le 49 caselle!</p>
            <div class="victory-stats">
                <div class="victory-stat">
                    <div class="victory-stat-value" id="victory-score">0</div>
                    <div class="victory-stat-label">Punteggio Finale</div>
                </div>
                <div class="victory-stat">
                    <div class="victory-stat-value" id="victory-streak">0</div>
                    <div class="victory-stat-label">Serie Migliore</div>
                </div>
            </div>
            <button class="primary victory-button" onclick="closeVictory()">üèÜ Salva e Vedi Classifica</button>
        </div>
    </div>

    <div class="bonus-notification" id="bonus-notification"></div>

    <div class="monster-popup" id="monster-popup">
        <div class="monster-container">
            <div class="monster-emoji" id="monster-emoji"></div>
            <div class="monster-text" id="monster-text">COLPITO!</div>
        </div>
    </div>

    <!-- MALUS POPUP -->
    <div class="malus-popup" id="malus-popup">
        <div class="malus-container">
            <span class="malus-emoji">üòà</span>
            <div class="malus-text" id="malus-text"></div>
        </div>
    </div>

    <!-- CARD MALUS POPUP -->
    <div class="card-malus-popup" id="card-malus-popup">
        <div class="card-malus-container">
            <div class="card-malus-emoji">üé¥</div>
            <h2 class="card-malus-title">CARTE MALEDETTE!</h2>
            <p class="card-malus-subtitle">Scegli una carta...<br>Perderai 1, 2 o 3 bonus!</p>
            <div class="cards-container" id="cards-container">
                <div class="card" onclick="selectCard(0)">
                    <div class="card-back">?</div>
                </div>
                <div class="card" onclick="selectCard(1)">
                    <div class="card-back">?</div>
                </div>
                <div class="card" onclick="selectCard(2)">
                    <div class="card-back">?</div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FIREBASE CONFIGURATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const firebaseConfig = {
        apiKey: "AIzaSyDamBv3u0gvX6zdA7w0LUL75JTRlgt6MtU",
        authDomain: "grid-survivor.firebaseapp.com",
        databaseURL: "https://grid-survivor-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "grid-survivor",
        storageBucket: "grid-survivor.firebasestorage.app",
        messagingSenderId: "65681965353",
        appId: "1:65681965353:web:a5ff81cfcbc2657308f738"
    };

    // Inizializza Firebase
    let database = null;
    let useOnlineLeaderboard = false;

    try {
        firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        useOnlineLeaderboard = true;
        console.log('‚úÖ Firebase connected - online leaderboard active');
    } catch (error) {
        console.warn('‚ö†Ô∏è Firebase not configured - using local leaderboard only');
        console.warn('To enable online leaderboard, follow GUIDA_PUBBLICAZIONE.md');
        useOnlineLeaderboard = false;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GAME CODE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚îÄ‚îÄ‚îÄ AudioContext per i suoni dei personaggi ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let audioCtx = null;
    function getAudioCtx() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
    }

    // Suono di tick del timer
    function playTickSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(1200, now);
        g.gain.setValueAtTime(0.15, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        o.start(now);
        o.stop(now + 0.05);
    }

    // Suono perdita vita - tono scendente drammatico
    function playLifeLostSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(600, now);
        o.frequency.exponentialRampToValueAtTime(150, now + 0.4);
        g.gain.setValueAtTime(0.3, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        o.start(now);
        o.stop(now + 0.4);
    }

    // Suono attivazione scudo - tono crescente protettivo
    function playShieldSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(400, now);
        o.frequency.exponentialRampToValueAtTime(800, now + 0.2);
        g.gain.setValueAtTime(0.25, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        o.start(now);
        o.stop(now + 0.3);
    }

    // Toggle audio on/off
    function toggleSound() {
        soundEnabled = !soundEnabled;
        document.getElementById('sound-icon').textContent = soundEnabled ? 'üîä' : 'üîá';
    }

    // Risata malefice del Malus: 3 note discendenti distorte + rumore
    function playEvilLaughSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;

        // Rumore di fondo basso e cupo
        const bufLen = ctx.sampleRate * 1.2;
        const buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < bufLen; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.6));
        const noise = ctx.createBufferSource(); noise.buffer = buf;
        const nf = ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.value = 250;
        const ng = ctx.createGain(); ng.gain.setValueAtTime(0.15, now); ng.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
        noise.connect(nf); nf.connect(ng); ng.connect(ctx.destination);
        noise.start(now);

        // 3 "ha" distortati: note gravi che scendono, con distorsione (sawtooth)
        const notes = [
            { freq: 160, start: 0,    dur: 0.25 },
            { freq: 130, start: 0.28, dur: 0.25 },
            { freq: 105, start: 0.56, dur: 0.35 }
        ];
        notes.forEach(({ freq, start, dur }) => {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            const dist = ctx.createWaveShaper();
            // curva di distorsione
            const curve = new Float32Array(256);
            for (let i = 0; i < 256; i++) {
                const x = (i * 2) / 256 - 1;
                curve[i] = (Math.PI + 200) * x / (Math.PI + 200 * Math.abs(x));
            }
            dist.curve = curve;
            dist.oversample = '4x';

            o.connect(dist); dist.connect(g); g.connect(ctx.destination);
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(freq, now + start);
            o.frequency.exponentialRampToValueAtTime(freq * 0.7, now + start + dur);
            g.gain.setValueAtTime(0, now + start);
            g.gain.linearRampToValueAtTime(0.3, now + start + 0.04);
            g.gain.exponentialRampToValueAtTime(0.001, now + start + dur);
            o.start(now + start);
            o.stop(now + start + dur);
        });
    }

    // Genera un suono sintetizzato con parametri diversi per ogni personaggio
    function playMonsterSound(monsterIndex) {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;

        // Parametri unici per ciascuno dei 10 personaggi
        const sounds = [
            // 0 üëæ ‚Äî bip elettronico acuto
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'square'; o.frequency.setValueAtTime(880, now);
                o.frequency.exponentialRampToValueAtTime(440, now + 0.15);
                g.gain.setValueAtTime(0.3, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                o.start(now); o.stop(now + 0.3);
            },
            // 1 üëª ‚Äî gemito fantasma (rumore filtrato)
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.4, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.15));
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 300; f.Q.value = 3;
                const g = ctx.createGain(); g.gain.value = 0.4;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 2 üéÉ ‚Äî basso profondo pulsante
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'sine'; o.frequency.setValueAtTime(80, now);
                o.frequency.exponentialRampToValueAtTime(40, now + 0.4);
                g.gain.setValueAtTime(0.5, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                o.start(now); o.stop(now + 0.5);
            },
            // 3 ü¶á ‚Äî strillo acuto rapido
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'sawtooth'; o.frequency.setValueAtTime(1200, now);
                o.frequency.exponentialRampToValueAtTime(200, now + 0.25);
                g.gain.setValueAtTime(0.25, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                o.start(now); o.stop(now + 0.25);
            },
            // 4 ü§ñ ‚Äî beep metallico doppio
            () => {
                [0, 0.12].forEach(delay => {
                    const o = ctx.createOscillator(); const g = ctx.createGain();
                    o.connect(g); g.connect(ctx.destination);
                    o.type = 'square'; o.frequency.value = 660;
                    g.gain.setValueAtTime(0, now + delay);
                    g.gain.linearRampToValueAtTime(0.2, now + delay + 0.03);
                    g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.13);
                    o.start(now + delay); o.stop(now + delay + 0.13);
                });
            },
            // 5 üåë ‚Äî sussurro oscuro (noise grave)
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.25));
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 150;
                const g = ctx.createGain(); g.gain.value = 0.35;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 6 üêô ‚Äî gorgoglio acquatico
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.35, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.3 * Math.sin(i * 0.05);
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 500; f.Q.value = 1.5;
                const g = ctx.createGain(); g.gain.value = 0.4;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 7 üíÄ ‚Äî nota funebre lenta
            () => {
                [0, 0.18, 0.36].forEach((delay, i) => {
                    const o = ctx.createOscillator(); const g = ctx.createGain();
                    o.connect(g); g.connect(ctx.destination);
                    o.type = 'sine'; o.frequency.value = [220, 185, 165][i];
                    g.gain.setValueAtTime(0, now + delay);
                    g.gain.linearRampToValueAtTime(0.2, now + delay + 0.04);
                    g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.17);
                    o.start(now + delay); o.stop(now + delay + 0.17);
                });
            },
            // 8 üî• ‚Äî crepitio di fuoco
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.08));
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 800;
                const g = ctx.createGain(); g.gain.value = 0.3;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 9 ‚ö° ‚Äî zap elettrico
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'sawtooth'; o.frequency.setValueAtTime(400, now);
                o.frequency.exponentialRampToValueAtTime(2000, now + 0.08);
                o.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                g.gain.setValueAtTime(0.3, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                o.start(now); o.stop(now + 0.2);
            }
        ];
        if (sounds[monsterIndex]) sounds[monsterIndex]();
    }

    // ‚îÄ‚îÄ‚îÄ Costanti ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const GRID_SIZE = 7;
    const TIMER_DURATION = 8;          // pi√π tempo per giocare con calma
    const BASE_POINTS = 10;
    const POINTS_MULTIPLIER = 1.5;
    const MAX_BONUSES_PER_GAME = 10;

    const BONUS_TYPES = [
        { id: 'shield',        name: 'SCUDO',    icon: 'üõ°Ô∏è',  description: 'Ti salva dalla prossima colpita' },
        { id: 'eliminate3',    name: 'TRIPLO',   icon: 'üí£',  description: 'Elimina 3 caselle sicure' },
        { id: 'sniper',        name: 'SNIPER',   icon: 'üéØ',  description: 'Elimina 1 casella rossa garantita' },
        { id: 'vision',        name: 'VISIONE',  icon: 'üëÅÔ∏è',  description: 'Rivela caselle sicure' },
        { id: 'magnet',        name: 'MAGNETE',  icon: 'üß≤',  description: 'Rivela tutti i bonus rimasti per 3 secondi' },
        { id: 'lucky',         name: 'FORTUNA',  icon: 'üé≤',  description: 'Dimezza le celle rosse per il prossimo turno' },
        { id: 'extraLife',     name: 'VITA+',    icon: '‚ù§Ô∏è',  description: 'Guadagna una vita extra (max 3)' }
    ];

    // Bonus punti: uno di questi sostituisce doublePoints in modo casuale
    const POINT_BONUSES = [
        { id: 'doublePoints',  name: 'x2 PUNTI', icon: 'üí∞',  description: 'Doppi punti per 3 turni' },
        { id: 'points1000',    name: '+1000',    icon: 'üíµ',  description: '+1000 punti immediati' },
        { id: 'points5000',    name: '+5000',    icon: 'üí∏',  description: '+5000 punti immediati' },
        { id: 'points10000',   name: '+10000',   icon: 'üíé',  description: '+10000 punti immediati' }
    ];

    // Malus: truffa nascosta, 50% di possibilit√† di apparire nella partita
    const MALUS_TRAP = { id: 'malus', name: 'SFORTUNA', icon: 'üòà', description: 'Prossimo turno: doppio rischio!' };
    const CARD_MALUS = { id: 'cardMalus', name: 'CARTE', icon: 'üé¥', description: 'Scegli una carta: perdi 1, 2 o 3 bonus!' };

    // 10 personaggi con emoji unici
    const MONSTERS = [
        { emoji: 'üëæ', text: 'COLPITO!' },
        { emoji: 'üëª', text: 'BOO! COLPITO!' },
        { emoji: 'üéÉ', text: 'PRESO!' },
        { emoji: 'ü¶á', text: 'MORSO!' },
        { emoji: 'ü§ñ', text: 'ERRORE FATALE!' },
        { emoji: 'üåë', text: 'INGHIOTTITO!' },
        { emoji: 'üêô', text: 'TRASCINATO!' },
        { emoji: 'üíÄ', text: 'FINE!' },
        { emoji: 'üî•', text: 'BRUCIATO!' },
        { emoji: '‚ö°', text: 'FULMINATO!' }
    ];

    // Emoji disponibili per il profilo nella classifica
    const PROFILE_EMOJIS = ['üòé', 'üèÜ', '‚öîÔ∏è', 'üéÆ', 'üåü', 'ü¶Ö', 'üêâ', 'üí™', 'üéØ', 'üî•', 'üëë', '‚≠ê', 'üíé', 'üöÄ', '‚ö°'];

    // ‚îÄ‚îÄ‚îÄ Stato del gioco ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let gameState = {
        score: 0,
        cellsEliminated: 0,
        currentStreak: 0,
        bestStreak: 0,
        selectedCell: null,
        eliminatedCells: new Set(),
        timerInterval: null,
        timeRemaining: TIMER_DURATION,
        isGameActive: false,
        roundNumber: 0,
        bonusCells: new Map(),
        collectedBonuses: [],
        activeShield: false,
        doublePointsRemaining: 0,
        visionActive: false,
        safeCells: [],
        isProcessingReveal: false,
        dangerZone: { row: 0, col: 0, dir: { dr: 1, dc: 1 } }, // epicentro + direzione
        lifelineActive: false,   // lifeline attiva per questo round
        lifelineCells: [],       // le 5 caselle accese dal lifeline
        lives: 3,                // vite disponibili
        pointsStreak: 0,         // caselle consecutive senza colpita (esponente punti)
        isPaused: false,         // true durante le notifiche bonus (blocca tutto)
        luckyActive: false,      // dimezza le celle rosse per 1 turno
        malusActive: false,      // doppio rossi al prossimo turno
        malusFound: false,       // trovato questo turno, si attiva al prossimo
        allBonusesInGame: null,  // snapshot dei bonus reali della partita
        gameStarted: false,      // true dopo "Nuova Partita"
        bonusHintShown: false    // hint scroll mostrato solo la prima volta
    };

    let selectedProfileEmoji = PROFILE_EMOJIS[0]; // emoji di default
    let soundEnabled = true; // controllo audio globale

    // ‚îÄ‚îÄ‚îÄ Inizializzazione griglia ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function initGrid() {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';
        gameState.bonusCells = new Map();

        // Celle interni: escludi il perimetro (riga 0/6, colonna 0/6)
        const interiorPositions = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const row = Math.floor(i / GRID_SIZE);
            const col = i % GRID_SIZE;
            if (row > 0 && row < GRID_SIZE - 1 && col > 0 && col < GRID_SIZE - 1) {
                interiorPositions.push(i);
            }
        }
        shuffle(interiorPositions);

        // Bonus diversi da extraLife
        const regularBonuses = BONUS_TYPES.filter(b => b.id !== 'extraLife');
        const extraLifeBonus = BONUS_TYPES.find(b => b.id === 'extraLife');
        
        // Scegli un bonus punti casuale da POINT_BONUSES
        const selectedPointBonus = (POINT_BONUSES && POINT_BONUSES.length > 0) 
            ? POINT_BONUSES[Math.floor(Math.random() * POINT_BONUSES.length)]
            : { id: 'doublePoints', name: 'x2 PUNTI', icon: 'üí∞', description: 'Doppi punti per 3 turni' };
        
        // Crea pool di bonus regolari + il bonus punti scelto
        const bonusPool = [...regularBonuses, selectedPointBonus];
        
        // Probabilit√† vite extra: 50% per 1, 25% per 2, 10% per 3, 15% per 0
        const rand = Math.random();
        let extraLivesCount;
        if (rand < 0.15) extraLivesCount = 0;       // 15% nessuna vita extra
        else if (rand < 0.65) extraLivesCount = 1;  // 50% una vita (0.15 + 0.50)
        else if (rand < 0.90) extraLivesCount = 2;  // 25% due vite (0.65 + 0.25)
        else extraLivesCount = 3;                    // 10% tre vite (restante)
        
        // Aggiungi le vite extra nelle prime posizioni (se ce ne sono)
        for (let i = 0; i < extraLivesCount; i++) {
            gameState.bonusCells.set(interiorPositions[i], extraLifeBonus);
        }

        // Riempi il resto con bonus dal pool (regolari + 1 bonus punti)
        // Crea un pool pi√π grande per evitare troppi duplicati consecutivi
        const expandedPool = [];
        // Aggiungi ogni bonus 1-2 volte per distribuire meglio
        bonusPool.forEach(bonus => {
            expandedPool.push(bonus);
            // 70% chance di aggiungere una seconda copia
            if (Math.random() < 0.7) {
                expandedPool.push(bonus);
            }
        });
        shuffle(expandedPool);
        
        // Riempi gli slot rimanenti
        for (let b = extraLivesCount; b < MAX_BONUSES_PER_GAME; b++) {
            const poolIndex = (b - extraLivesCount) % expandedPool.length;
            gameState.bonusCells.set(interiorPositions[b], expandedPool[poolIndex]);
        }

        // MALUS: Solo UNO per partita! Scegli casualmente tra Sfortuna e Carte
        const malusRoll = Math.random();
        if (malusRoll < 0.5) {
            // 50% Malus Sfortuna (ultimo slot)
            gameState.bonusCells.set(interiorPositions[MAX_BONUSES_PER_GAME - 1], MALUS_TRAP);
        } else if (malusRoll < 0.7 && extraLivesCount < MAX_BONUSES_PER_GAME - 1) {
            // 20% Card Malus (penultimo slot) - solo se non occupato da vite extra
            gameState.bonusCells.set(interiorPositions[MAX_BONUSES_PER_GAME - 2], CARD_MALUS);
        }
        // 30% nessun malus (malusRoll >= 0.7)

        // Salva snapshot dei bonus reali della partita (esclusi malus) per la barra
        gameState.allBonusesInGame = [];
        gameState.bonusCells.forEach((bonus) => {
            if (bonus.id !== 'malus' && bonus.id !== 'cardMalus') {
                gameState.allBonusesInGame.push({ id: bonus.id, name: bonus.name, icon: bonus.icon });
            }
        });

        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.dataset.index = i;
            cell.addEventListener('click', () => selectCell(i));
            grid.appendChild(cell);
        }
        updateBonusDisplay();
        initDangerZone();
    }

    function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // ‚îÄ‚îÄ‚îÄ Zona di pericolo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // L'epicentro si muove ogni round in una direzione diagonale e "rimbalza"
    // contro i bordi della griglia come una pallina da biliardo.
    // Le caselle pi√π vicine all'epicentro hanno una probabilit√† maggiore di essere
    // estratte come caselle rosse; quelle lontane una probabilit√† minore.

    function initDangerZone() {
        const row = 1 + Math.floor(Math.random() * (GRID_SIZE - 2));
        const col = 1 + Math.floor(Math.random() * (GRID_SIZE - 2));
        const signs = [-1, 1];
        const dr = signs[Math.floor(Math.random() * 2)];
        const dc = signs[Math.floor(Math.random() * 2)];
        gameState.dangerZone = { row, col, dir: { dr, dc } };
        // Nessun rendering: la zona √® nascosta
    }

    function moveDangerZone() {
        const dz = gameState.dangerZone;
        let newRow = dz.row + dz.dir.dr;
        let newCol = dz.col + dz.dir.dc;

        if (newRow < 0 || newRow >= GRID_SIZE) {
            dz.dir.dr *= -1;
            newRow = dz.row + dz.dir.dr;
        }
        if (newCol < 0 || newCol >= GRID_SIZE) {
            dz.dir.dc *= -1;
            newCol = dz.col + dz.dir.dc;
        }

        dz.row = newRow;
        dz.col = newCol;
        // Nessun rendering: la zona resta nascosta
    }

    // Partiziona il pool in caselle DENTRO la zona (dist <= 2) e FUORI.
    // Poi pescano ~75% dalle caselle dentro e il resto dalle caselle fuori,
    // garantendo una concentrazione forte delle rosse nella zona senza
    // rivelare nulla visivamente.
    function extractDangerCells(pool, count) {
        const dz = gameState.dangerZone;

        const inside = [];
        const outside = [];
        pool.forEach(idx => {
            const row = Math.floor(idx / GRID_SIZE);
            const col = idx % GRID_SIZE;
            const dist = Math.max(Math.abs(row - dz.row), Math.abs(col - dz.col));
            if (dist <= 2) inside.push(idx);
            else outside.push(idx);
        });

        shuffle(inside);
        shuffle(outside);

        // Quante pescane dalla zona: 80% del totale richiesto, ma non pi√π di quelle disponibili dentro
        const fromInside = Math.min(inside.length, Math.round(count * 0.80));
        const fromOutside = Math.min(outside.length, count - fromInside);

        return inside.slice(0, fromInside).concat(outside.slice(0, fromOutside));
    }

    // ‚îÄ‚îÄ‚îÄ Selezione cella ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function selectCell(index) {
        if (!gameState.gameStarted) return; // blocca finch√© non clicchi "Nuova Partita"
        if (gameState.isPaused) return; // blocca durante notifiche bonus
        if (gameState.isProcessingReveal) return;
        if (gameState.eliminatedCells.has(index)) return;
        if (gameState.selectedCell === index) return;

        // Ferma il timer (il giocatore ha scelto)
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;

        // Deseleziona la cella precedente
        if (gameState.selectedCell !== null) {
            const prev = document.querySelector(`[data-index="${gameState.selectedCell}"]`);
            if (prev) prev.classList.remove('selected');
        }

        gameState.selectedCell = index;
        const cell = document.querySelector(`[data-index="${index}"]`);
        cell.classList.add('selected');

        // Controlla bonus nascosto
        if (gameState.bonusCells.has(index)) {
            const bonusTemplate = gameState.bonusCells.get(index);
            gameState.bonusCells.delete(index);

            if (bonusTemplate.id === 'malus') {
                // MALUS SFORTUNA: non va nei bonus raccolti, attiva subito il popup del mostro
                showMalusPopup();
            } else if (bonusTemplate.id === 'cardMalus') {
                // CARD MALUS: attiva popup carte maledette
                showCardMalusPopup();
            } else {
                // Bonus normale: crea una COPIA, non usare il riferimento!
                const bonus = {
                    id: bonusTemplate.id,
                    name: bonusTemplate.name,
                    icon: bonusTemplate.icon,
                    description: bonusTemplate.description,
                    used: false,
                    uniqueId: Date.now() + Math.random()
                };
                gameState.collectedBonuses.push(bonus);
                showBonusNotification(bonus);
                updateBonusDisplay();
            }
        }

        gameState.isProcessingReveal = true;
        
        // CHECK VITTORIA IMMEDIATA: se questa √® l'ultima casella disponibile, hai vinto!
        // Conta quante celle NON eliminate ci sono (esclusa quella appena selezionata che sar√† eliminata)
        let remainingCells = 0;
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== index) {
                remainingCells++;
            }
        }
        
        if (remainingCells === 0) {
            // VITTORIA! Questa era l'ultima casella
            updateMessage('üéâ ULTIMA CASELLA! HAI VINTO!', 'success');
            setTimeout(() => showVictory(), 1000);
            return; // Non chiamare revealCell()
        }
        
        updateMessage('Casella selezionata! Attendi la rivelazione...', 'info');
        setTimeout(() => revealCell(), 500);
    }

    // ‚îÄ‚îÄ‚îÄ Preview bonus ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showBonusPreview() {
        return new Promise(resolve => {
            // Mostra messaggio
            updateMessage('üéÅ MEMORIZZA I BONUS!', 'info');

            // Crea array delle celle bonus in ordine casuale
            const bonusCellsArray = Array.from(gameState.bonusCells.entries());
            shuffle(bonusCellsArray);

            // Accendi in sequenza
            const totalDuration = 5000; // 5 secondi totali
            const delayBetween = totalDuration / bonusCellsArray.length;
            const showDuration = 400; // quanto resta accesa ogni cella

            bonusCellsArray.forEach(([cellIndex, bonus], i) => {
                setTimeout(() => {
                    const cell = document.querySelector(`[data-index="${cellIndex}"]`);
                    if (cell) {
                        cell.classList.add('bonus-preview');
                        cell.textContent = bonus.icon;
                        
                        // Spegni dopo showDuration
                        setTimeout(() => {
                            cell.classList.remove('bonus-preview');
                            cell.textContent = '';
                        }, showDuration);
                    }
                }, i * delayBetween);
            });

            // Dopo tutta la sequenza
            setTimeout(() => {
                updateMessage('Seleziona una casella!', 'info');
                resolve();
            }, totalDuration);
        });
    }

    // ‚îÄ‚îÄ‚îÄ Avvio partita ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function startGame() {
        resetGame();
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('reset-btn').style.display = 'inline-block';
        
        // Prima mostra il preview dei bonus
        await showBonusPreview();
        
        // Abilita il gioco
        gameState.gameStarted = true;
        
        // Poi avvia il timer
        setTimeout(() => {
            startTimer();
            updateLives(); // forza il re-render delle vite
        }, 50);
    }

    // ‚îÄ‚îÄ‚îÄ Timer (perimetro griglia) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function startTimer(retryCount = 0) {
        clearInterval(gameState.timerInterval);
        gameState.timeRemaining = TIMER_DURATION;

        const wrap  = document.getElementById('grid-wrap');
        const svg   = document.getElementById('timer-perimeter');
        const rect  = document.getElementById('timer-rect');

        // Misura la griglia dopo il layout
        const w = wrap.offsetWidth;
        const h = wrap.offsetHeight;

        // Se le dimensioni non sono ancora pronte, riprova (max 10 tentativi)
        if ((w < 50 || h < 50) && retryCount < 10) {
            setTimeout(() => startTimer(retryCount + 1), 20);
            return;
        }

        // Mostra il timer
        svg.classList.add('active');

        const strokeW = 6;
        const pad = strokeW / 2;          // centra lo stroke sul bordo
        const rx = 10;

        // Imposta dimensioni del rect nell'SVG (coordinate nel viewBox = pixel della griglia)
        svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
        rect.setAttribute('x', pad);
        rect.setAttribute('y', pad);
        rect.setAttribute('width',  w - strokeW);
        rect.setAttribute('height', h - strokeW);
        rect.setAttribute('rx', rx);
        rect.setAttribute('ry', rx);

        // Perimetro del rettangolo arrotondato: 2*(w+h) ‚àí 8*rx + 2*œÄ*rx
        const perim = 2 * (w - strokeW + h - strokeW) - 8 * rx + 2 * Math.PI * rx;

        rect.style.strokeDasharray  = perim;
        rect.style.strokeDashoffset = 0;
        svg.classList.remove('warning', 'danger');

        gameState.timerInterval = setInterval(() => {
            gameState.timeRemaining -= 0.1;
            if (gameState.timeRemaining < 0) gameState.timeRemaining = 0;

            // Aggiorna perimetro
            const pct    = gameState.timeRemaining / TIMER_DURATION;
            rect.style.strokeDashoffset = perim * (1 - pct);

            // Colore
            svg.classList.remove('warning', 'danger');
            if (gameState.timeRemaining <= 2)      svg.classList.add('danger');
            else if (gameState.timeRemaining <= 4) svg.classList.add('warning');

            // Ticchettio con frequenza crescente
            const secondsInt = Math.floor(gameState.timeRemaining);
            const fraction = gameState.timeRemaining - secondsInt;
            if (gameState.timeRemaining > 3) {
                // > 3s: tick ogni 1s
                if (fraction >= 0.9 && fraction < 1.0) playTickSound();
            } else if (gameState.timeRemaining > 1.5) {
                // 1.5-3s: tick ogni 0.5s
                if ((fraction >= 0.4 && fraction < 0.5) || (fraction >= 0.9 && fraction < 1.0)) playTickSound();
            } else if (gameState.timeRemaining > 0) {
                // < 1.5s: tick ogni 0.3s
                if ((fraction >= 0.2 && fraction < 0.3) || (fraction >= 0.5 && fraction < 0.6) || (fraction >= 0.8 && fraction < 0.9)) playTickSound();
            }

            // Tempo scaduto
            if (gameState.timeRemaining <= 0) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
                gameState.isProcessingReveal = true;
                updateMessage('‚è∞ Tempo scaduto! Non hai selezionato nessuna casella!', 'danger');
                setTimeout(() => endGame(), 1500);
            }
        }, 100);
    }

    // ‚îÄ‚îÄ‚îÄ Rivelazione caselle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function revealCell() {
        gameState.isGameActive = false;

        if (gameState.selectedCell === null) {
            // Nessuna cella selezionata (non dovrebbe succedere qui, gestito nel timer)
            updateMessage('‚è∞ Tempo scaduto!', 'danger');
            setTimeout(() => endGame(), 1500);
            return;
        }

        const userSelectedCell = gameState.selectedCell;

        // Pool delle caselle ancora disponibili
        const availableCells = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i)) availableCells.push(i);
        }

        // Questo check non dovrebbe mai scattare perch√© la vittoria viene rilevata in selectCell
        // Ma lo lasciamo come safety net
        if (availableCells.length === 0) {
            setTimeout(() => showVictory(), 1000);
            return;
        }

        // Calcola quante caselle rosse estrarre
        let cellsToReveal = calculateDifficulty(availableCells.length);
        
        // Applica effetto LUCKY: dimezza le celle rosse per questo turno
        if (gameState.luckyActive) {
            cellsToReveal = Math.ceil(cellsToReveal / 2);
            gameState.luckyActive = false; // consumato dopo un turno
        }

        // Applica effetto MALUS: raddoppia le celle rosse per questo turno
        if (gameState.malusActive) {
            cellsToReveal = Math.min(cellsToReveal * 2, availableCells.length - 1); // lascia almeno 1 cella libera
            gameState.malusActive = false; // consumato dopo un turno
        }

        // Se il malus √® stato trovato QUESTO turno, promuovilo per il prossimo
        if (gameState.malusFound) {
            gameState.malusFound = false;
            gameState.malusActive = true; // si attiva al PROSSIMO revealCell
        }
        
        cellsToReveal = Math.min(cellsToReveal, availableCells.length);

        // Pool per l'estrazione delle caselle rosse.
        // Escludi le caselle protette dalla visione ‚Äî inclusa quella dell'utente se l'ha scelta.
        // Se l'utente ha scelto una casella visione-safe, √® protetto: non pu√≤ essere colpito.
        const dangerPool = availableCells.filter(idx =>
            !gameState.safeCells.includes(idx)
        );

        // Se il dangerPool √® vuoto (tutte le caselle rimaste sono protette dalla visione)
        // pescana comunque dalle disponibili normalmente
        const effectivePool = dangerPool.length > 0 ? dangerPool : availableCells;

        // Estrai le caselle rosse: ~75% dalla zona di pericolo nascosta, resto casuale
        const randomCells = extractDangerCells(effectivePool, Math.min(cellsToReveal, effectivePool.length));

        // L'utente √® colpito se la sua cella √® stata estratta
        let userWasHit = randomCells.includes(userSelectedCell);

        // ‚îÄ‚îÄ Scudo: gestione corretta ‚îÄ‚îÄ
        let shieldUsed = false;
        if (userWasHit && gameState.activeShield) {
            userWasHit = false;
            shieldUsed = true;
            gameState.activeShield = false;
            updateShieldIndicator();
            updateBonusDisplay();
        }

        // Elimina la casella scelta dall'utente (sempre sicura)
        const selectedEl = document.querySelector(`[data-index="${userSelectedCell}"]`);
        selectedEl.classList.remove('selected');
        selectedEl.classList.add('eliminated');
        gameState.eliminatedCells.add(userSelectedCell);
        gameState.cellsEliminated++;
        gameState.currentStreak++;
        if (gameState.currentStreak > gameState.bestStreak) gameState.bestStreak = gameState.currentStreak;

        // Punti con moltiplicatore esponenziale sulla serie corrente + doppio se attivo
        gameState.pointsStreak++;
        let points = Math.round(BASE_POINTS * Math.pow(POINTS_MULTIPLIER, gameState.pointsStreak - 1));
        if (gameState.doublePointsRemaining > 0) {
            points *= 2;
            gameState.doublePointsRemaining--;
        }
        gameState.score += points;
        if (gameState.currentStreak >= 3) showCombo();
        createParticles(selectedEl);
        updateStats();
        updateMessage(`+${points} punti! Attendi la rivelazione...`, 'info');

        // Dopo 500ms ‚Üí mostra le caselle rosse
        setTimeout(() => {
            randomCells.forEach(idx => {
                const el = document.querySelector(`[data-index="${idx}"]`);
                if (!gameState.eliminatedCells.has(idx)) el.classList.add('revealed');
            });

            // Dopo altri 1000ms ‚Üí messaggio risultato
            setTimeout(() => {
                if (shieldUsed) {
                    showBonusNotification({ name: 'SCUDO USATO!', icon: 'üõ°Ô∏è', description: 'Sei stato salvato!' });
                    updateMessage(`üõ°Ô∏è Lo scudo ti ha salvato! Una delle caselle rosse era la tua!`, 'success');

                } else if (userWasHit && gameState.lifelineActive) {
                    // ‚îÄ‚îÄ Lifeline: almeno una delle 5 caselle deve sopravvivere ‚îÄ‚îÄ
                    const survivors = gameState.lifelineCells.filter(idx => !randomCells.includes(idx));

                    if (survivors.length > 0) {
                        // Almeno una casella sopravvisse ‚Üí salvi!
                        // Evidenzia la prima sopravvissuta in verde brillante
                        const survivorEl = document.querySelector(`[data-index="${survivors[0]}"]`);
                        if (survivorEl) {
                            survivorEl.classList.remove('lifeline-active');
                            survivorEl.classList.add('lifeline-survived');
                        }
                        showBonusNotification({ name: 'LIFELINE!', icon: 'üÜò', description: 'Una casella ti ha salvato!' });
                        updateMessage(`üÜò LIFELINE! Una delle tue caselle √® sopravvissuta!`, 'success');
                    } else {
                        // Tutte e 5 le caselle lifeline sono rosse ‚Üí perdi una vita
                        selectedEl.classList.add('hit');
                        updateMessage(`üí• LIFELINE FALLITO! Tutte le caselle sono cadute!`, 'danger');
                        loseLife();
                        return;
                    }

                } else if (userWasHit) {
                    // Colpito senza scudo n√© lifeline ‚Üí perdi una vita
                    selectedEl.classList.add('hit');
                    updateMessage(`üí• OH NO! Una delle ${cellsToReveal} caselle era la tua!`, 'danger');
                    loseLife();
                    return;

                } else {
                    updateMessage(`‚úÖ Salvo! Nessuna delle ${cellsToReveal} caselle era la tua. Continua!`, 'success');
                }

                // Cleanup dopo 1500ms
                setTimeout(() => {
                    randomCells.forEach(idx => {
                        const el = document.querySelector(`[data-index="${idx}"]`);
                        el.classList.remove('revealed');
                    });
                    clearVision();
                    clearLifeline();
                    gameState.selectedCell = null;
                    gameState.isProcessingReveal = false;

                    // Muovi la zona di pericolo per il prossimo round
                    moveDangerZone();

                    updateMessage('Seleziona la prossima casella!', 'info');

                    // Riavvia il timer per il prossimo round
                    startTimer();
                }, 1500);
            }, 1000);
        }, 500);
    }

    // ‚îÄ‚îÄ‚îÄ Difficolt√† dinamica ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function calculateDifficulty(remainingCells) {
        const total = GRID_SIZE * GRID_SIZE; // 49
        const pct = remainingCells / total;

        // Parte da 15, scende lentamente ‚Äî la pressione resta alta fino alla fine
        if (pct > 0.9)  return 15;  // ~45 rimaste ‚Üí 15 rosse (~33%)
        if (pct > 0.8)  return 14;  // ~40 rimaste ‚Üí 14 rosse (~35%)
        if (pct > 0.7)  return 12;  // ~35 rimaste ‚Üí 12 rosse (~34%)
        if (pct > 0.6)  return 10;  // ~30 rimaste ‚Üí 10 rosse (~33%)
        if (pct > 0.5)  return 8;   // ~25 rimaste ‚Üí  8 rosse (~32%)
        if (pct > 0.4)  return 7;   // ~20 rimaste ‚Üí  7 rosse (~35%)
        if (pct > 0.3)  return 5;   // ~15 rimaste ‚Üí  5 rosse (~33%)
        if (pct > 0.2)  return 4;   // ~10 rimaste ‚Üí  4 rosse (~40%)
        if (pct > 0.1)  return 2;   // ~5  rimaste ‚Üí  2 rosse (~40%)
        return 1;
    }

    // ‚îÄ‚îÄ‚îÄ Combo display ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showCombo() {
        const combo = document.getElementById('combo');
        let text = '';
        if (gameState.currentStreak >= 10)      text = 'üî• LEGGENDARIO! x' + gameState.currentStreak + ' üî•';
        else if (gameState.currentStreak >= 7)  text = '‚ö° INCREDIBILE! x' + gameState.currentStreak + ' ‚ö°';
        else if (gameState.currentStreak >= 5)  text = '‚ú® FANTASTICO! x' + gameState.currentStreak + ' ‚ú®';
        else if (gameState.currentStreak >= 3)  text = 'üéØ COMBO x' + gameState.currentStreak + '!';
        combo.textContent = text;
        setTimeout(() => { combo.textContent = ''; }, 2000);
    }

    // ‚îÄ‚îÄ‚îÄ Bonus: notifica, display, attivazione ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showBonusNotification(bonus, onComplete) {
        // Pausa il gioco: blocca le interazioni E ferma il timer
        gameState.isPaused = true;
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
        
        const el = document.getElementById('bonus-notification');
        el.innerHTML = `${bonus.icon} ${bonus.name}!<br><small style="font-size:0.5em;">${bonus.description}</small>`;
        el.classList.add('show');
        
        setTimeout(() => {
            el.classList.remove('show');
            gameState.isPaused = false;
            // Se c'√® un callback (es. attivazione differita di visione/magnete), eseguilo
            if (onComplete) onComplete();
            // Riavvia il timer se il gioco √® iniziato e non siamo nel mezzo di una rivelazione
            if (gameState.gameStarted && !gameState.isProcessingReveal) {
                startTimer();
            }
        }, 2500);
    }

    function updateBonusDisplay() {
        const container = document.getElementById('bonuses');
        container.innerHTML = '';

        // Se non c'√® ancora lo snapshot (prima di initGrid) non fare nulla
        if (!gameState.allBonusesInGame) return;

        // Costruisci una copia della lista dei bonus raccolti ancora disponibili per il matching
        // Uso un array di flag per evitare di matchare lo stesso bonus raccolto due volte
        const collectedUsed = gameState.collectedBonuses.map(() => false);

        gameState.allBonusesInGame.forEach((slotBonus) => {
            // Cerca un bonus raccolto corrispondente che non sia gi√† stato matchato
            let matchIdx = -1;
            for (let i = 0; i < gameState.collectedBonuses.length; i++) {
                if (!collectedUsed[i] && gameState.collectedBonuses[i].id === slotBonus.id) {
                    matchIdx = i;
                    break;
                }
            }

            const card = document.createElement('div');

            if (matchIdx !== -1) {
                // ‚îÄ‚îÄ Bonus gi√† raccolto ‚îÄ‚îÄ
                collectedUsed[matchIdx] = true;
                const collected = gameState.collectedBonuses[matchIdx];
                
                // Gestisci bonus rimosso dal card malus
                if (collected.removed) {
                    card.className = 'bonus-card removed';
                    card.innerHTML = `<div class="bonus-icon">${collected.icon}</div><div class="bonus-name">${collected.name}</div>`;
                    card.style.cursor = 'not-allowed';
                    card.title = 'Rimosso da Card Malus';
                } else if (collected.used) {
                    card.className = 'bonus-card used';
                    card.innerHTML = `<div class="bonus-icon">${collected.icon}</div><div class="bonus-name">${collected.name}</div>`;
                    card.style.cursor = 'not-allowed';
                    card.title = 'Gi√† usato';
                } else {
                    card.className = 'bonus-card';
                    card.innerHTML = `<div class="bonus-icon">${collected.icon}</div><div class="bonus-name">${collected.name}</div>`;
                    card.addEventListener('click', () => activateBonus(collected.uniqueId));
                }
            } else {
                // ‚îÄ‚îÄ Ancora sulla griglia (non trovato) ‚îÄ‚îÄ
                card.className = 'bonus-card disabled';
                card.innerHTML = `<div class="bonus-icon">${slotBonus.icon}</div><div class="bonus-name">${slotBonus.name}</div>`;
                card.title = 'Non ancora trovato';
            }

            container.appendChild(card);
        });

        // Controlla se la barra √® scrollabile e aggiorna stile + hint
        const bonusContainer = document.getElementById('bonuses');
        const hint = document.getElementById('bonus-scroll-hint');
        
        // Aspetta che il DOM si aggiorni per misure corrette
        setTimeout(() => {
            const isScrollable = bonusContainer.scrollWidth > bonusContainer.clientWidth;
            
            if (isScrollable) {
                // Aggiungi classe per allineamento sinistra + gradient
                bonusContainer.classList.add('scrollable');
                
                // Mostra hint solo la PRIMA volta
                if (!gameState.bonusHintShown && gameState.collectedBonuses.length === 1) {
                    gameState.bonusHintShown = true; // marca come mostrato
                    
                    hint.style.display = 'block';
                    hint.style.opacity = '0';
                    setTimeout(() => { hint.style.opacity = '1'; }, 10);
                    hint.style.transition = 'opacity 0.3s ease';
                    
                    // Nascondi dopo 3 secondi con fade-out
                    setTimeout(() => {
                        hint.style.opacity = '0';
                        setTimeout(() => { hint.style.display = 'none'; }, 300);
                    }, 3000);
                }
            } else {
                // Rimuovi classe per centrare
                bonusContainer.classList.remove('scrollable');
                hint.style.display = 'none';
            }
        }, 50);
    }

    function activateBonus(uniqueId) {
        // Trova il bonus tramite uniqueId
        const bonus = gameState.collectedBonuses.find(b => b.uniqueId === uniqueId);
        if (!bonus) return;
        if (gameState.isPaused) return; // blocca durante notifiche
        if (bonus.used) return; // gi√† usato
        if (bonus.removed) return; // rimosso dal Card Malus
        
        // Marca come usato SOLO questo specifico bonus tramite uniqueId
        bonus.used = true;

        switch (bonus.id) {
            case 'shield':
                gameState.activeShield = true;
                updateShieldIndicator();
                playShieldSound();
                showBonusNotification({ name: 'SCUDO ATTIVO! üòà', icon: 'üõ°Ô∏è', description: 'Sarai salvato al prossimo colpo' });
                break;
            case 'eliminate3':
                eliminateRandomCells(3);
                showBonusNotification({ name: 'BOOM!', icon: 'üí£', description: '3 caselle sicure eliminate!' });
                break;
            case 'sniper':
                activateSniper();
                showBonusNotification({ name: 'SNIPER!', icon: 'üéØ', description: '1 casella rossa eliminata!' });
                break;
            case 'vision':
                // Mostra prima il messaggio, poi attiva la visione dopo che sparisce
                showBonusNotification({ name: 'VISIONE ATTIVA!', icon: 'üëÅÔ∏è', description: 'Caselle sicure evidenziate!' }, () => {
                    activateVision();
                });
                break;
            case 'magnet':
                // Mostra prima il messaggio, poi attiva il magnete dopo che sparisce
                showBonusNotification({ name: 'MAGNETE!', icon: 'üß≤', description: 'Tutti i bonus rivelati per 3 secondi!' }, () => {
                    activateMagnet();
                });
                break;
            case 'lucky':
                gameState.luckyActive = true;
                showBonusNotification({ name: 'FORTUNA!', icon: 'üé≤', description: 'Met√† celle rosse al prossimo turno!' });
                break;
            case 'doublePoints':
                gameState.doublePointsRemaining = 3;
                showBonusNotification({ name: 'PUNTI x2!', icon: 'üí∞', description: 'Doppi punti per 3 turni!' });
                break;
            case 'points1000':
                gameState.score += 1000;
                updateStats();
                showBonusNotification({ name: '+1000 PUNTI!', icon: 'üíµ', description: 'Punti bonus immediati!' });
                break;
            case 'points5000':
                gameState.score += 5000;
                updateStats();
                showBonusNotification({ name: '+5000 PUNTI!', icon: 'üí∏', description: 'Jackpot bonus!' });
                break;
            case 'points10000':
                gameState.score += 10000;
                updateStats();
                showBonusNotification({ name: '+10000 PUNTI!', icon: 'üíé', description: 'SUPER JACKPOT!' });
                break;
            case 'extraLife':
                if (gameState.lives < 3) {
                    gameState.lives++;
                    updateLives();
                    showBonusNotification({ name: 'VITA EXTRA! ‚ù§Ô∏è', icon: '‚ù§Ô∏è', description: 'Hai guadagnato una vita!' });
                } else {
                    showBonusNotification({ name: 'VITA PIENA! ‚ù§Ô∏è', icon: '‚ù§Ô∏è', description: 'Hai gi√† il massimo delle vite!' });
                }
                break;
        }
        updateBonusDisplay();
    }

    function updateShieldIndicator() {
        document.getElementById('shield-badge').classList.toggle('show', gameState.activeShield);
    }

    // ‚îÄ‚îÄ‚îÄ Vite ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function updateLives() {
        const container = document.getElementById('lives');
        container.innerHTML = '';
        for (let i = 0; i < 3; i++) {
            const heart = document.createElement('span');
            heart.className = 'life-heart' + (i >= gameState.lives ? ' lost' : '');
            heart.textContent = i < gameState.lives ? '‚ù§Ô∏è' : 'üñ§';
            container.appendChild(heart);
        }
    }

    function loseLife() {
        gameState.lives--;
        gameState.currentStreak = 0;
        gameState.pointsStreak  = 0;
        updateStats();
        updateLives();
        playLifeLostSound(); // suono perdita vita

        if (gameState.lives <= 0) {
            // Ultima vita persa ‚Üí game over
            const monsterIdx = Math.floor(Math.random() * MONSTERS.length);
            playMonsterSound(monsterIdx);
            setTimeout(() => {
                showMonster(monsterIdx);
                setTimeout(() => endGame(), 2000);
            }, 1000);
        } else {
            // Ancora vite rimaste ‚Üí riprendi dopo una pausa
            updateMessage(`üíî Vita persa! Ne rimangono ${gameState.lives}. Attento!`, 'danger');
            setTimeout(() => {
                document.querySelectorAll('.revealed').forEach(el => el.classList.remove('revealed'));
                clearVision();
                clearLifeline();
                gameState.selectedCell = null;
                gameState.isProcessingReveal = false;
                moveDangerZone();
                updateMessage('Seleziona la prossima casella!', 'info');
                startTimer();
            }, 2000);
        }
    }

    function eliminateRandomCells(count) {
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) available.push(i);
        }
        shuffle(available);
        available.slice(0, Math.min(count, available.length)).forEach(idx => {
            gameState.eliminatedCells.add(idx);
            const el = document.querySelector(`[data-index="${idx}"]`);
            el.classList.add('eliminated');
            createParticles(el);
        });
        
        // CHECK VITTORIA: se dopo aver eliminato le caselle non ne rimangono pi√π
        checkVictoryAfterElimination();
    }
    
    function checkVictoryAfterElimination() {
        let remainingCells = 0;
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) {
                remainingCells++;
            }
        }
        
        if (remainingCells === 0) {
            // VITTORIA! Tutte le caselle eliminate (incluse quelle con bonus)
            clearInterval(gameState.timerInterval);
            gameState.timerInterval = null;
            updateMessage('üéâ ULTIMA CASELLA ELIMINATA! HAI VINTO!', 'success');
            setTimeout(() => showVictory(), 1500);
        }
    }

    // ‚îÄ‚îÄ‚îÄ Visione: rivela caselle sicure e le MEMORIZZA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateVision() {
        clearVision(); // pulisci eventuale visione precedente

        gameState.visionActive = true;
        gameState.safeCells = [];

        // Trova tutte le caselle non ancora eliminate e non quella selezionata
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) available.push(i);
        }

        // Mostra esattamente 3 caselle sicure (indipendente dalle rimaste)
        const count = Math.min(3, available.length);
        shuffle(available);
        gameState.safeCells = available.slice(0, count);

        gameState.safeCells.forEach(idx => {
            const el = document.querySelector(`[data-index="${idx}"]`);
            el.classList.add('vision-safe');
        });
    }

    function clearVision() {
        document.querySelectorAll('.vision-safe').forEach(el => el.classList.remove('vision-safe'));
        gameState.visionActive = false;
        gameState.safeCells = [];
    }

    // ‚îÄ‚îÄ‚îÄ Lifeline ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateLifeline() {
        clearLifeline();
        gameState.lifelineActive = true;

        // Pescana 5 caselle random tra quelle non ancora eliminate (escludi quella selezionata)
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) available.push(i);
        }
        shuffle(available);
        gameState.lifelineCells = available.slice(0, Math.min(5, available.length));

        // Accendi visivamente le 5 caselle in oro
        gameState.lifelineCells.forEach(idx => {
            const el = document.querySelector(`[data-index="${idx}"]`);
            if (el) el.classList.add('lifeline-active');
        });
    }

    function clearLifeline() {
        document.querySelectorAll('.lifeline-active, .lifeline-survived').forEach(el => {
            el.classList.remove('lifeline-active', 'lifeline-survived');
        });
        gameState.lifelineActive = false;
        gameState.lifelineCells = [];
    }

    // ‚îÄ‚îÄ‚îÄ Sniper: elimina 1 casella rossa garantita ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateSniper() {
        // Trova tutte le celle disponibili (non eliminate, non selezionate)
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) {
                available.push(i);
            }
        }
        
        if (available.length === 0) return;
        
        // Scegli una casella casuale e marcala come "safe" cos√¨ non verr√† mai scelta come rossa
        const targetIdx = available[Math.floor(Math.random() * available.length)];
        gameState.eliminatedCells.add(targetIdx);
        
        const el = document.querySelector(`[data-index="${targetIdx}"]`);
        el.classList.add('eliminated');
        createParticles(el);
        
        // Effetto visivo speciale per sniper (flash rosso poi verde)
        el.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        setTimeout(() => {
            el.style.background = '';
        }, 300);
        
        // CHECK VITTORIA: se sniper ha eliminato l'ultima casella
        checkVictoryAfterElimination();
    }

    // ‚îÄ‚îÄ‚îÄ Magnet: rivela tutti i bonus rimasti per 3 secondi ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateMagnet() {
        // Trova tutti i bonus non ancora raccolti
        const bonusPositions = [];
        gameState.bonusCells.forEach((bonus, cellIdx) => {
            bonusPositions.push({ idx: cellIdx, bonus: bonus });
        });
        
        if (bonusPositions.length === 0) {
            // Nessun bonus rimasto
            return;
        }
        
        // Mostra tutti i bonus con l'icona per 3 secondi
        bonusPositions.forEach(({ idx, bonus }) => {
            const cell = document.querySelector(`[data-index="${idx}"]`);
            if (cell && !gameState.eliminatedCells.has(idx)) {
                cell.classList.add('magnet-reveal');
                cell.textContent = bonus.icon;
            }
        });
        
        // Nascondi dopo 3 secondi
        setTimeout(() => {
            bonusPositions.forEach(({ idx }) => {
                const cell = document.querySelector(`[data-index="${idx}"]`);
                if (cell) {
                    cell.classList.remove('magnet-reveal');
                    cell.textContent = '';
                }
            });
        }, 3000);
    }

    // ‚îÄ‚îÄ‚îÄ Particelle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function createParticles(cell) {
        const rect = cell.getBoundingClientRect();
        const container = document.querySelector('.game-container');
        const cRect = container.getBoundingClientRect();
        for (let i = 0; i < 8; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.left = (rect.left - cRect.left + rect.width / 2) + 'px';
            p.style.top  = (rect.top  - cRect.top  + rect.height / 2) + 'px';
            p.style.transform = `translate(${Math.random() * 60 - 30}px, ${Math.random() * 60 - 30}px)`;
            container.appendChild(p);
            setTimeout(() => p.remove(), 1000);
        }
    }

    // ‚îÄ‚îÄ‚îÄ Mostro ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showMonster(monsterIdx) {
        const monster = MONSTERS[monsterIdx];
        document.getElementById('monster-emoji').textContent = monster.emoji;
        document.getElementById('monster-text').textContent  = monster.text;
        const popup = document.getElementById('monster-popup');
        popup.classList.add('show');
        setTimeout(() => popup.classList.remove('show'), 2000);
    }

    // ‚îÄ‚îÄ‚îÄ Malus popup: mostro cattivo che ride ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showMalusPopup() {
        // Calcola celle libere rimaste (escludi quelle gi√† eliminate)
        const freeCells = (GRID_SIZE * GRID_SIZE) - gameState.eliminatedCells.size;

        // Pausa tutto
        gameState.isPaused = true;
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;

        // Attiva l'effetto malus per il prossimo turno (non questo!)
        gameState.malusFound = true;

        // Risata
        playEvilLaughSound();

        // Messaggio dalla bocca del mostro
        document.getElementById('malus-text').innerHTML =
            `Bonus <span class="malus-highlight">Sfortuna</span>...<br>solo <span class="malus-highlight">${freeCells} caselle libere</span>`;

        const popup = document.getElementById('malus-popup');
        popup.classList.add('show');

        // Dopo 2.8s chiudi e riavvia
        setTimeout(() => {
            popup.classList.remove('show');
            gameState.isPaused = false;
            if (gameState.gameStarted && !gameState.isProcessingReveal) {
                startTimer();
            }
        }, 2800);
    }

    // ‚îÄ‚îÄ‚îÄ Card Malus Popup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let cardMalusValues = [];
    
    function showCardMalusPopup() {
        // Pausa tutto
        gameState.isPaused = true;
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;

        // Genera valori casuali delle carte (1, 2, 3 in ordine casuale)
        cardMalusValues = [1, 2, 3];
        shuffle(cardMalusValues);

        // Mostra popup
        const popup = document.getElementById('card-malus-popup');
        popup.classList.add('show');
        
        // Suono inquietante
        playCardMalusSound();
    }

    function selectCard(cardIndex) {
        const lostBonusCount = cardMalusValues[cardIndex];
        
        // Animazione flip
        const cards = document.querySelectorAll('.card');
        cards[cardIndex].classList.add('flipped');
        
        // Mostra il valore
        setTimeout(() => {
            cards[cardIndex].querySelector('.card-back').textContent = lostBonusCount;
            cards[cardIndex].style.background = lostBonusCount === 1 ? 
                'linear-gradient(135deg, #10b981 0%, #059669 100%)' : 
                lostBonusCount === 2 ?
                'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' :
                'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        }, 300);

        // Dopo 1.5s rimuovi i bonus e chiudi
        setTimeout(() => {
            removeBonuses(lostBonusCount);
            const popup = document.getElementById('card-malus-popup');
            popup.classList.remove('show');
            
            // Reset cards per prossima volta
            cards.forEach(card => {
                card.classList.remove('flipped');
                card.querySelector('.card-back').textContent = '?';
                card.style.background = 'linear-gradient(135deg, #4f46e5 0%, #6366f1 100%)';
            });
            
            gameState.isPaused = false;
            if (gameState.gameStarted && !gameState.isProcessingReveal) {
                startTimer();
            }
        }, 2000);
    }

    function removeBonuses(count) {
        let actuallyRemoved = 0;
        const removedBonusTypes = []; // traccia quali bonus sono stati rimossi dalla griglia
        
        // 1. Rimuovi bonus dalla GRIGLIA (se ancora presenti e non raccolti)
        const bonusesToRemove = [];
        gameState.bonusCells.forEach((bonus, cellIdx) => {
            if (actuallyRemoved < count && bonus.id !== 'malus' && bonus.id !== 'cardMalus') {
                bonusesToRemove.push({ cellIdx, bonus });
                actuallyRemoved++;
            }
        });
        
        bonusesToRemove.forEach(({ cellIdx, bonus }) => {
            gameState.bonusCells.delete(cellIdx);
            removedBonusTypes.push({ id: bonus.id, name: bonus.name, icon: bonus.icon });
        });
        
        // 2. Crea "placeholder" nei collectedBonuses per i bonus rimossi dalla griglia
        // cos√¨ appariranno barrati nella barra anche se non erano stati raccolti
        removedBonusTypes.forEach(bonusType => {
            gameState.collectedBonuses.push({
                id: bonusType.id,
                name: bonusType.name,
                icon: bonusType.icon,
                uniqueId: Date.now() + Math.random(),
                used: false,
                removed: true // subito marcato come rimosso
            });
        });
        
        // 3. Marca anche bonus raccolti come "removed" se non bastano quelli dalla griglia
        let stillNeedToRemove = count - bonusesToRemove.length;
        if (stillNeedToRemove > 0) {
            // Prima marca i non-usati
            for (let i = gameState.collectedBonuses.length - 1; i >= 0 && stillNeedToRemove > 0; i--) {
                const bonus = gameState.collectedBonuses[i];
                if (!bonus.removed && !bonus.used) {
                    bonus.removed = true;
                    stillNeedToRemove--;
                    actuallyRemoved++;
                }
            }
            
            // Poi se serve, marca anche quelli usati
            if (stillNeedToRemove > 0) {
                for (let i = gameState.collectedBonuses.length - 1; i >= 0 && stillNeedToRemove > 0; i--) {
                    const bonus = gameState.collectedBonuses[i];
                    if (!bonus.removed && bonus.used) {
                        bonus.removed = true;
                        stillNeedToRemove--;
                        actuallyRemoved++;
                    }
                }
            }
        }
        
        // Aggiorna display
        updateBonusDisplay();
        
        // Messaggio
        if (actuallyRemoved > 0) {
            updateMessage(`üíÄ Hai perso ${actuallyRemoved} bonus!`, 'danger');
        } else {
            updateMessage(`üòÖ Nessun bonus da perdere!`, 'info');
        }
    }

    function playCardMalusSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        
        // Suono discendente inquietante
        [400, 350, 300, 250].forEach((freq, i) => {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.connect(g);
            g.connect(ctx.destination);
            o.type = 'triangle';
            o.frequency.setValueAtTime(freq, now + i * 0.1);
            g.gain.setValueAtTime(0.2, now + i * 0.1);
            g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.2);
            o.start(now + i * 0.1);
            o.stop(now + i * 0.1 + 0.2);
        });
    }

    // ‚îÄ‚îÄ‚îÄ Vittoria ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showVictory() {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
        gameState.isGameActive = false;

        // Popola statistiche
        document.getElementById('victory-score').textContent = gameState.score.toLocaleString();
        document.getElementById('victory-streak').textContent = gameState.bestStreak;

        // Crea confetti
        createConfetti();

        // Mostra overlay
        document.getElementById('victory-overlay').classList.add('show');

        // Suono vittoria
        playVictorySound();
    }

    function closeVictory() {
        document.getElementById('victory-overlay').classList.remove('show');
        // Apri direttamente il game over per salvare punteggio
        endGame();
    }

    function createConfetti() {
        const container = document.getElementById('victory-confetti');
        container.innerHTML = '';
        const colors = ['#fbbf24', '#f59e0b', '#ef4444', '#10b981', '#3b82f6', '#8b5cf6'];
        
        for (let i = 0; i < 50; i++) {
            const confetto = document.createElement('div');
            confetto.style.position = 'absolute';
            confetto.style.width = '10px';
            confetto.style.height = '10px';
            confetto.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetto.style.left = Math.random() * 100 + '%';
            confetto.style.top = '-20px';
            confetto.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
            confetto.style.opacity = '0.8';
            confetto.style.animation = `confettiFall ${2 + Math.random() * 3}s linear ${Math.random() * 2}s infinite`;
            container.appendChild(confetto);
        }
    }

    // Aggiungi animazione confetti al CSS inline
    if (!document.getElementById('confetti-style')) {
        const style = document.createElement('style');
        style.id = 'confetti-style';
        style.textContent = `
            @keyframes confettiFall {
                to {
                    transform: translateY(600px) rotate(${Math.random() * 720 - 360}deg);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }

    function playVictorySound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        
        // Sequenza ascendente di note trionfali
        const notes = [261.63, 329.63, 392.00, 523.25]; // C, E, G, C alto
        notes.forEach((freq, i) => {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.connect(g);
            g.connect(ctx.destination);
            o.type = 'sine';
            o.frequency.setValueAtTime(freq, now + i * 0.15);
            g.gain.setValueAtTime(0.3, now + i * 0.15);
            g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.3);
            o.start(now + i * 0.15);
            o.stop(now + i * 0.15 + 0.3);
        });
    }

    // ‚îÄ‚îÄ‚îÄ Stats ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function updateStats() {
        document.getElementById('score').textContent            = gameState.score;
        document.getElementById('cells-eliminated').textContent = gameState.cellsEliminated;
        document.getElementById('streak').textContent           = gameState.currentStreak;
    }

    function updateMessage(text, type) {
        const el = document.getElementById('message');
        el.textContent = text;
        el.className = 'message ' + type;
    }

    // ‚îÄ‚îÄ‚îÄ Fine partita ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function endGame() {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
        gameState.isGameActive = false;

        document.getElementById('final-score').textContent  = gameState.score;
        document.getElementById('final-cells').textContent  = gameState.cellsEliminated;
        document.getElementById('final-streak').textContent = gameState.bestStreak;

        // Controlla se il punteggio entra nei primi 10 (verifica ONLINE se disponibile)
        let leaderboard = [];
        
        if (useOnlineLeaderboard && database) {
            try {
                const snapshot = await database.ref('leaderboard').orderByChild('score').limitToLast(10).once('value');
                const data = snapshot.val();
                if (data) {
                    leaderboard = Object.values(data);
                    leaderboard.sort((a, b) => b.score - a.score);
                }
            } catch (error) {
                console.error('Error checking online leaderboard:', error);
                // Fallback a locale
                leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
            }
        } else {
            leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
        }
        
        const qualifies = leaderboard.length < 10 || gameState.score > (leaderboard[leaderboard.length - 1]?.score || 0);

        document.getElementById('save-section').style.display    = qualifies ? 'block' : 'none';
        document.getElementById('no-save-section').style.display = qualifies ? 'none'  : 'block';

        if (qualifies) {
            // Reset input e emoji picker
            document.getElementById('player-name').value = '';
            document.getElementById('save-btn').disabled = true;
            selectedProfileEmoji = PROFILE_EMOJIS[0];
            renderEmojiPicker();
        }

        document.getElementById('game-over').classList.add('show');
    }

    // ‚îÄ‚îÄ‚îÄ Emoji picker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function renderEmojiPicker() {
        const container = document.getElementById('emoji-picker');
        container.innerHTML = '';
        PROFILE_EMOJIS.forEach((emoji, i) => {
            const div = document.createElement('div');
            div.className = 'emoji-option' + (emoji === selectedProfileEmoji ? ' selected-emoji' : '');
            div.textContent = emoji;
            div.addEventListener('click', () => {
                selectedProfileEmoji = emoji;
                renderEmojiPicker();
            });
            container.appendChild(div);
        });
    }

    function onNameInput() {
        const name = document.getElementById('player-name').value.trim();
        document.getElementById('save-btn').disabled = name.length === 0;
    }

    // ‚îÄ‚îÄ‚îÄ Classifica ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function saveToLeaderboard() {
        const playerName = document.getElementById('player-name').value.trim();
        if (!playerName) return;

        const entry = {
            name: playerName,
            emoji: selectedProfileEmoji,
            score: gameState.score,
            cells: gameState.cellsEliminated,
            streak: gameState.bestStreak,
            date: new Date().toLocaleDateString('it-IT'),
            timestamp: Date.now()
        };

        // Salva locale (fallback se Firebase non funziona)
        let localLeaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
        localLeaderboard.push(entry);
        localLeaderboard.sort((a, b) => b.score - a.score);
        localLeaderboard = localLeaderboard.slice(0, 10);
        localStorage.setItem('gridSurvivorLeaderboard', JSON.stringify(localLeaderboard));

        // Salva online se Firebase √® configurato
        if (useOnlineLeaderboard && database) {
            try {
                await database.ref('leaderboard').push(entry);
                console.log('‚úÖ Score saved to online leaderboard');
            } catch (error) {
                console.error('‚ùå Failed to save online:', error);
                alert('Punteggio salvato localmente. La classifica online non √® disponibile.');
            }
        }

        document.getElementById('game-over').classList.remove('show');
        showLeaderboard(gameState.score); // passa il punteggio dell'utente per highlight
    }

    async function showLeaderboard(userScore = null) {
        const container = document.getElementById('leaderboard-list');
        const statusEl = document.getElementById('firebase-status');
        
        container.innerHTML = '<p style="padding:20px;color:#666;">‚è≥ Caricamento classifica...</p>';
        document.getElementById('leaderboard-overlay').classList.add('show');

        // Mostra stato connessione
        if (useOnlineLeaderboard) {
            statusEl.innerHTML = 'üåê Classifica Online Globale';
            statusEl.style.color = '#10b981';
        } else {
            statusEl.innerHTML = 'üíæ Classifica Locale (solo questo dispositivo)';
            statusEl.style.color = '#f59e0b';
        }

        let leaderboard = [];

        // Carica da Firebase se disponibile
        if (useOnlineLeaderboard && database) {
            try {
                const snapshot = await database.ref('leaderboard').orderByChild('score').limitToLast(50).once('value');
                const data = snapshot.val();
                
                if (data) {
                    leaderboard = Object.values(data);
                    leaderboard.sort((a, b) => b.score - a.score);
                    leaderboard = leaderboard.slice(0, 10);
                    console.log('‚úÖ Loaded online leaderboard:', leaderboard.length, 'entries');
                }
            } catch (error) {
                console.error('‚ùå Failed to load online leaderboard:', error);
                statusEl.innerHTML = '‚ö†Ô∏è Errore caricamento online - Mostrando classifica locale';
                statusEl.style.color = '#ef4444';
                // Fallback a locale
                leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
            }
        } else {
            // Usa solo locale
            leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
        }

        // Renderizza
        if (leaderboard.length === 0) {
            container.innerHTML = '<p style="padding:20px;color:#666;">Nessun punteggio ancora. Sii il primo!</p>';
        } else {
            container.innerHTML = leaderboard.map((entry, i) => {
                let cls = 'leaderboard-entry';
                let medal = '';
                let badge = '';
                
                // Check if this is user's just-saved entry
                const isUserEntry = userScore !== null && entry.score === userScore && entry.timestamp > (Date.now() - 10000); // last 10 seconds
                
                if (i === 0) { cls += ' top1'; medal = 'ü•á '; }
                else if (i === 1) { cls += ' top2'; medal = 'ü•à '; }
                else if (i === 2) { cls += ' top3'; medal = 'ü•â '; }
                
                if (isUserEntry) {
                    cls += ' user-entry';
                    badge = ' <span class="new-badge">üÜï TU</span>';
                }

                return `<div class="${cls}">
                    <div>${medal}${entry.emoji || 'üë§'} ${i + 1}. ${entry.name}${badge}</div>
                    <div><strong>${entry.score}</strong> pts</div>
                </div>`;
            }).join('');
        }
    }

    function closeLeaderboard() {
        document.getElementById('leaderboard-overlay').classList.remove('show');
        // Non resettare il gioco: il giocatore potrebbe averlo aperto durante una partita
    }

    function confirmResetLeaderboard() {
        const confirmed = confirm('‚ö†Ô∏è ATTENZIONE!\n\nQuesto canceller√† TUTTI i punteggi dalla classifica online.\n\nSei sicuro?');
        if (confirmed) {
            const doubleCheck = confirm('Conferma di nuovo: vuoi davvero cancellare TUTTA la classifica globale?');
            if (doubleCheck) {
                resetLeaderboard();
            }
        }
    }

    async function resetLeaderboard() {
        // Reset locale
        localStorage.removeItem('gridSurvivorLeaderboard');
        
        // Reset Firebase se disponibile
        if (useOnlineLeaderboard && database) {
            try {
                await database.ref('leaderboard').remove();
                console.log('‚úÖ Online leaderboard cleared');
                alert('‚úÖ Classifica online cancellata con successo!');
            } catch (error) {
                console.error('‚ùå Failed to clear online leaderboard:', error);
                alert('‚ùå Errore: impossibile cancellare la classifica online.\nVerifica le regole Firebase.');
            }
        }

        // Aggiorna visualizzazione
        if (document.getElementById('leaderboard-overlay').classList.contains('show')) {
            showLeaderboard();
        }
    }

    function closeGameOver() {
        document.getElementById('game-over').classList.remove('show');
        resetGame();
    }

    // ‚îÄ‚îÄ‚îÄ Reset ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function resetGame() {
        clearInterval(gameState.timerInterval);

        gameState = {
            score: 0,
            cellsEliminated: 0,
            currentStreak: 0,
            bestStreak: 0,
            selectedCell: null,
            eliminatedCells: new Set(),
            timerInterval: null,
            timeRemaining: TIMER_DURATION,
            isGameActive: false,
            roundNumber: 0,
            bonusCells: new Map(),
            collectedBonuses: [],
            activeShield: false,
            doublePointsRemaining: 0,
            visionActive: false,
            safeCells: [],
            isProcessingReveal: false,
            dangerZone: { row: 0, col: 0, dir: { dr: 1, dc: 1 } },
            lifelineActive: false,
            lifelineCells: [],
            lives: 3,
            pointsStreak: 0,
            isPaused: false,
            luckyActive: false,
            malusActive: false,
            malusFound: false,
            allBonusesInGame: null,
            gameStarted: false,
            bonusHintShown: false
        };

        initGrid();
        updateStats();
        updateLives();
        updateShieldIndicator();
        updateBonusDisplay(); // Reset della visualizzazione bonus

        // Reset timer perimetrale visuale
        const svg  = document.getElementById('timer-perimeter');
        const rect = document.getElementById('timer-rect');
        rect.style.strokeDashoffset = 0;
        svg.classList.remove('warning', 'danger');

        document.getElementById('combo').textContent = '';
        updateMessage('Seleziona una casella per iniziare!', 'info');
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('reset-btn').style.display = 'inline-block';
    }

    // ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Admin reset via URL: ?admin=GRIDWIN2024
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('admin') === 'GRIDWIN2024') {
        // Crea pulsante admin reset
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'üîê ADMIN: Reset Classifica';
        adminBtn.className = 'secondary';
        adminBtn.style.position = 'fixed';
        adminBtn.style.bottom = '20px';
        adminBtn.style.right = '20px';
        adminBtn.style.zIndex = '9999';
        adminBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        adminBtn.style.color = 'white';
        adminBtn.style.border = 'none';
        adminBtn.onclick = async () => {
            if (!confirm('‚ö†Ô∏è ADMIN: Cancellare TUTTA la classifica online?')) return;
            if (!confirm('ULTIMA CONFERMA: Sei ASSOLUTAMENTE sicuro?')) return;
            
            try {
                if (useOnlineLeaderboard && database) {
                    await database.ref('leaderboard').remove();
                    alert('‚úÖ Classifica online cancellata con successo!');
                }
                localStorage.removeItem('gridSurvivorLeaderboard');
                alert('‚úÖ Classifica locale cancellata!');
                window.location.reload();
            } catch (error) {
                alert('‚ùå Errore: ' + error.message);
            }
        };
        document.body.appendChild(adminBtn);
        console.log('üîê Admin mode active');
    }
    
    initGrid();
    renderEmojiPicker();
    </script>
</body>
</html>
