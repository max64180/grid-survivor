<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Survivor - Sopravvivi alla Griglia!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            position: relative;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 6px;
            font-size: 1.6em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .subtitle {
            display: none;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr) auto;
            gap: 8px;
            margin-bottom: 4px;
            align-items: stretch;
        }

        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 4px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .stat-label {
            font-size: 0.7em;
            opacity: 0.9;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        /* VITE ‚Äî colonna 4 degli stat, allineate verticalmente al centro */
        .lives-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 3px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 6px 8px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .life-heart {
            font-size: 1.1em;
            line-height: 1;
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8));
        }
        .life-heart.lost {
            animation: heartLost 0.5s ease forwards;
        }
        @keyframes heartLost {
            0%   { transform: scale(1); }
            25%  { transform: scale(1.3) rotate(-12deg); }
            50%  { transform: scale(0.8) rotate(8deg); }
            100% { transform: scale(1); opacity: 0.35; }
        }

        /* SHIELD BADGE */
        .shield-badge {
            display: none;
            position: absolute;
            top: 95px;
            right: 16px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            font-size: 0.75em;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 20px;
            box-shadow: 0 3px 12px rgba(59,130,246,0.5);
            animation: shieldBadgePulse 1.8s ease infinite;
            white-space: nowrap;
            z-index: 10;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .shield-badge.show { display: block; }
        @keyframes shieldBadgePulse {
            0%, 100% { 
                box-shadow: 0 3px 12px rgba(59,130,246,0.5);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 3px 18px rgba(59,130,246,0.85);
                transform: scale(1.05);
            }
        }

        /* SOUND TOGGLE */
        .sound-toggle {
            position: absolute;
            top: 6px;
            left: 14px;
            font-size: 1.5em;
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s ease, opacity 0.2s ease;
            z-index: 10;
            opacity: 0.7;
        }
        .sound-toggle:hover {
            transform: scale(1.15);
            opacity: 1;
        }

        /* TIMER SUL PERIMETRO DELLA GRIGLIA */
        .grid-wrap {
            position: relative;
            margin-bottom: 10px;
        }
        .timer-perimeter {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            overflow: visible;
            opacity: 0; /* Nascosto fino a startTimer */
            transition: opacity 0.3s ease;
        }
        .timer-perimeter.active {
            opacity: 1;
        }
        .timer-perimeter rect {
            fill: none;
            stroke: #4ade80;
            stroke-width: 6;
            transition: stroke-dashoffset 0.1s linear;
            filter: drop-shadow(0 0 4px rgba(74,222,128,0.5));
        }
        .timer-perimeter.warning rect {
            stroke: #fbbf24;
            filter: drop-shadow(0 0 5px rgba(251,191,36,0.6));
        }
        .timer-perimeter.danger rect {
            stroke: #ef4444;
            filter: drop-shadow(0 0 7px rgba(239,68,68,0.75));
            animation: perimPulse 0.5s infinite;
        }
        @keyframes perimPulse {
            0%, 100% { opacity: 1; }
            50%      { opacity: 0.45; }
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            aspect-ratio: 1;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .grid-cell {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            border: 2px solid #ccc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            position: relative;
            overflow: visible; /* Cambiato da hidden a visible per permettere animazione punteggio */
        }

        .grid-cell:hover:not(.eliminated):not(.selected) {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            border-color: #667eea;
        }

        .grid-cell.selected {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #1d4ed8;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.5);
        }

        .grid-cell.revealed {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border-color: #b91c1c;
            color: white;
            animation: reveal 0.5s ease;
        }

        .grid-cell.eliminated {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-color: #047857;
            color: white;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .grid-cell.eliminated::after {
            content: '‚úì';
            position: absolute;
            font-size: 1.5em;
            color: white;
        }

        .grid-cell.bonus-preview {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            border-color: #f59e0b !important;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.8) !important;
            animation: bonusGlow 0.6s ease-in-out infinite;
            font-size: 1.8em !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        @keyframes bonusGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.8); }
            50%      { box-shadow: 0 0 35px rgba(251, 191, 36, 1); }
        }

        @keyframes reveal {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .message {
            text-align: center;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 0.9em;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message.info {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }

        .message.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .message.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .combo-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            font-weight: bold;
            color: #f59e0b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            z-index: 5;
            white-space: nowrap;
            animation: bounce 0.5s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50%      { transform: translate(-50%, -50%) scale(1.2); }
        }

        .button-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 18px;
            font-size: 0.9em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        button.primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button.secondary {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
        }

        button.secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(107, 114, 128, 0.4);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15) !important;
        }

        /* GAME OVER OVERLAY */
        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .game-over-overlay.show {
            display: flex;
        }

        .game-over-content {
            background: white;
            padding: 25px 20px;
            border-radius: 20px;
            text-align: center;
            max-width: 420px;
            width: 90%;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .game-over-content h2 {
            color: #ef4444;
            font-size: 2em;
            margin-bottom: 15px;
        }

        .final-stats {
            margin: 20px 0;
            font-size: 1.2em;
            color: #666;
        }

        .final-stats div {
            margin: 10px 0;
        }

        /* PARTICLES */
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #10b981;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFall 1s ease-out forwards;
        }

        @keyframes particleFall {
            to { transform: translateY(50px); opacity: 0; }
        }

        /* POSITION SCORE ANIMATION */
        .position-score {
            position: absolute;
            font-weight: bold;
            font-size: 1.4em;
            color: #fbbf24;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.9),
                         0 0 20px rgba(251, 191, 36, 0.6);
            pointer-events: none;
            z-index: 2500; /* Sopra le notifiche bonus (z-index: 2000) */
            animation: floatScore 1.2s ease-out forwards;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        /* Variante per punteggi ALTI (centro griglia) */
        .position-score.high-value {
            font-size: 1.8em;
            color: #f59e0b;
            text-shadow: 0 0 15px rgba(245, 158, 11, 1),
                         0 0 30px rgba(245, 158, 11, 0.8),
                         0 0 45px rgba(245, 158, 11, 0.5);
        }

        /* Responsive: font pi√π piccolo su mobile */
        @media (max-width: 768px) {
            .position-score {
                font-size: 0.9em; /* Ridotto ulteriormente da 1em */
            }
            .position-score.high-value {
                font-size: 1.1em; /* Ridotto ulteriormente da 1.3em */
            }
        }

        /* Responsive: font ancora pi√π piccolo su schermi molto piccoli */
        @media (max-width: 480px) {
            .position-score {
                font-size: 0.75em; /* Ridotto ulteriormente da 0.85em */
            }
            .position-score.high-value {
                font-size: 0.95em; /* Ridotto ulteriormente da 1.1em */
            }
        }

        @keyframes floatScore {
            0% { 
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 1;
            }
            30% {
                transform: translate(-50%, calc(-50% - 15px)) scale(1.2);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, calc(-50% - 50px)) scale(1.4);
                opacity: 0;
            }
        }

        /* BONUS */
        .bonuses-container {
            display: flex;
            gap: 4px;
            justify-content: center; /* Default: centrati */
            margin-bottom: 6px;
            flex-wrap: nowrap;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 4px 2px;
            position: relative;
        }

        /* Quando scrollabile: allinea a sinistra e aggiungi gradient fade */
        .bonuses-container.scrollable {
            justify-content: flex-start;
            -webkit-mask-image: linear-gradient(to right, transparent 0%, black 20px, black calc(100% - 20px), transparent 100%);
            mask-image: linear-gradient(to right, transparent 0%, black 20px, black calc(100% - 20px), transparent 100%);
        }

        /* Scrollbar personalizzata per bonus */
        .bonuses-container::-webkit-scrollbar {
            height: 4px;
        }
        .bonuses-container::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
        }
        .bonuses-container::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 10px;
        }
        .bonuses-container::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        .bonus-card {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            padding: 4px 6px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(251, 191, 36, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
            min-width: 42px;
            max-width: 42px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border: 1.5px solid #fbbf24;
            flex-shrink: 0;
        }

        .bonus-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
        }

        .bonus-card.disabled {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            border-color: #4b5563;
            opacity: 0.75;
            cursor: not-allowed;
            box-shadow: 0 2px 6px rgba(107, 114, 128, 0.3);
        }
        .bonus-card.disabled .bonus-icon { filter: grayscale(100%) brightness(1.4); opacity: 0.85; }
        .bonus-card.disabled .bonus-name { color: #d1d5db; opacity: 1; }
        .bonus-card.disabled:hover {
            transform: none;
            box-shadow: 0 2px 6px rgba(107, 114, 128, 0.3);
        }

        .bonus-card.used {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%) !important;
            border-color: #4b5563 !important;
            opacity: 0.6;
            cursor: not-allowed !important;
            position: relative;
        }
        .bonus-card.used:hover {
            transform: none !important;
            box-shadow: 0 2px 6px rgba(107, 114, 128, 0.3) !important;
        }
        .bonus-card.used::after {
            content: '‚úñ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            color: #dc2626;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }

        /* REMOVED BONUS (Card Malus) */
        .bonus-card.removed {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%) !important;
            border: 2px solid #312e81 !important;
            opacity: 0.5;
            cursor: not-allowed !important;
            position: relative;
        }
        .bonus-card.removed:hover {
            transform: none !important;
            box-shadow: 0 2px 6px rgba(99, 102, 241, 0.3) !important;
        }
        .bonus-card.removed::after {
            content: 'üíÄ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        .bonus-card .bonus-icon { 
            font-size: 1.1em; 
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 20px;
        }
        .bonus-card .bonus-name { 
            font-size: 0.55em; 
            font-weight: bold; 
            white-space: nowrap; 
        }

        .bonus-notification {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.95) 0%, rgba(245, 158, 11, 0.95) 100%);
            color: white;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 2em;
            font-weight: bold;
            z-index: 2000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: bonusPopup 0.5s ease;
            display: none;
            text-align: center;
            backdrop-filter: blur(8px);
        }

        .bonus-notification.show { display: block; }

        @keyframes bonusPopup {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* LIFELINE CELLS */
        .grid-cell.lifeline-active {
            background: linear-gradient(135deg, #fef08a 0%, #fde047 100%) !important;
            border-color: #ca8a04 !important;
            box-shadow: 0 0 14px rgba(250,204,21,0.7), inset 0 0 8px rgba(250,204,21,0.3) !important;
            animation: lifelinePulse 0.8s ease-in-out infinite !important;
        }
        @keyframes lifelinePulse {
            0%, 100% { box-shadow: 0 0 10px rgba(250,204,21,0.5), inset 0 0 6px rgba(250,204,21,0.2); }
            50%      { box-shadow: 0 0 22px rgba(250,204,21,0.85), inset 0 0 12px rgba(250,204,21,0.4); }
        }
        /* lifeline-survived: verde brillante, una delle 5 √® sopravvissuta */
        .grid-cell.lifeline-survived {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%) !important;
            border-color: #16a34a !important;
            box-shadow: 0 0 18px rgba(74,222,128,0.7) !important;
        }

        /* VISION SAFE CELLS */
        .grid-cell.vision-safe {
            border: 3px solid #10b981 !important;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.6), inset 0 0 10px rgba(16, 185, 129, 0.15) !important;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important;
        }

        /* MAGNET REVEAL */
        .grid-cell.magnet-reveal {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            border: 3px solid #f59e0b !important;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.8) !important;
            animation: magnetPulse 0.8s ease-in-out infinite;
            font-size: 1.5em !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        @keyframes magnetPulse {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 35px rgba(251, 191, 36, 1);
                transform: scale(1.05);
            }
        }

        /* HIT */
        .grid-cell.hit {
            border: 4px solid #ef4444 !important;
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%) !important;
            animation: hitPulse 0.5s ease-in-out 3;
        }

        @keyframes hitPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(239, 68, 68, 0.8); }
            50% { transform: scale(1.15); box-shadow: 0 0 40px rgba(239, 68, 68, 1); }
        }

        /* MONSTER POPUP */
        .monster-popup {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 3000;
            display: none;
            animation: monsterAppear 0.5s ease forwards;
        }

        .monster-popup.show { display: block; }

        @keyframes monsterAppear {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
            60% { transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }

        .monster-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            border: 5px solid #ef4444;
            backdrop-filter: blur(8px);
        }

        .monster-emoji {
            font-size: 8em;
            margin-bottom: 20px;
            animation: monsterBounce 0.6s ease-in-out infinite;
        }

        @keyframes monsterBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .monster-text {
            font-size: 2.5em;
            font-weight: bold;
            color: #ef4444;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* MALUS POPUP */
        .malus-popup {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .malus-popup.show { display: flex; }

        .malus-container {
            background: linear-gradient(160deg, #1a0a0a 0%, #2d1010 50%, #1a0a0a 100%);
            border: 3px solid #7f1d1d;
            border-radius: 28px;
            padding: 40px 50px;
            text-align: center;
            box-shadow: 0 0 60px rgba(200, 30, 30, 0.5), 0 0 120px rgba(180, 20, 20, 0.25);
            animation: malusPulse 0.6s ease-in-out infinite alternate;
            max-width: 420px;
        }

        @keyframes malusPulse {
            from { box-shadow: 0 0 60px rgba(200, 30, 30, 0.5), 0 0 120px rgba(180, 20, 20, 0.25); }
            to   { box-shadow: 0 0 80px rgba(220, 40, 40, 0.7), 0 0 140px rgba(200, 30, 30, 0.35); }
        }

        .malus-emoji {
            font-size: 7em;
            display: block;
            animation: malusShake 0.3s ease-in-out infinite alternate;
        }

        @keyframes malusShake {
            from { transform: rotate(-4deg) scale(1); }
            to   { transform: rotate(4deg) scale(1.05); }
        }

        .malus-text {
            color: #fca5a5;
            font-size: 1.6em;
            font-weight: bold;
            margin-top: 12px;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
            line-height: 1.3;
        }

        .malus-text .malus-highlight {
            color: #f87171;
            font-size: 1.15em;
        }

        /* CARD MALUS POPUP */
        .card-malus-popup {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .card-malus-popup.show { display: flex; }

        .card-malus-container {
            background: linear-gradient(160deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);
            border: 3px solid #6366f1;
            border-radius: 28px;
            padding: 40px 30px;
            text-align: center;
            box-shadow: 0 0 60px rgba(99, 102, 241, 0.5), 0 0 120px rgba(79, 70, 229, 0.25);
            animation: cardMalusPulse 0.8s ease-in-out infinite alternate;
            max-width: 500px;
        }

        @keyframes cardMalusPulse {
            from { box-shadow: 0 0 60px rgba(99, 102, 241, 0.5), 0 0 120px rgba(79, 70, 229, 0.25); }
            to   { box-shadow: 0 0 80px rgba(129, 140, 248, 0.7), 0 0 140px rgba(99, 102, 241, 0.35); }
        }

        .card-malus-emoji {
            font-size: 5em;
            animation: cardFloat 2s ease-in-out infinite;
        }

        @keyframes cardFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .card-malus-title {
            color: #c7d2fe;
            font-size: 2.2em;
            font-weight: bold;
            margin: 15px 0 10px;
            text-shadow: 0 0 15px rgba(99, 102, 241, 0.8);
        }

        .card-malus-subtitle {
            color: #a5b4fc;
            font-size: 1.1em;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .cards-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .card {
            width: 100px;
            height: 140px;
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            border: 3px solid #818cf8;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.6);
        }

        .card-back {
            font-size: 3em;
            animation: cardPulse 1.5s ease-in-out infinite;
        }

        @keyframes cardPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .card.flipped {
            animation: cardFlip 0.6s ease;
        }

        @keyframes cardFlip {
            0% { transform: rotateY(0); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0); }
        }

        /* LEADERBOARD */
        .leaderboard-container {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            margin: 20px auto;
        }

        .leaderboard-container h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 5px 0;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            border-radius: 8px;
            align-items: center;
            font-size: 0.85em;
        }

        .leaderboard-entry.top1 {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white; 
            font-weight: bold; 
            font-size: 0.95em;
        }

        .leaderboard-entry.top2 {
            background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
            color: white;
        }

        .leaderboard-entry.top3 {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
        }

        /* Leaderboard list with scrolling */
        #leaderboard-list {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            margin: 15px 0;
            padding-right: 5px;
        }

        /* Scrollbar styling for leaderboard */
        #leaderboard-list::-webkit-scrollbar {
            width: 6px;
        }
        #leaderboard-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #leaderboard-list::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        /* USER ENTRY HIGHLIGHT */
        .leaderboard-entry.user-entry {
            animation: userEntryPulse 2s ease infinite;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
            border: 2px solid #667eea;
        }

        @keyframes userEntryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .new-badge {
            display: inline-block;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            font-weight: bold;
            animation: badgeBounce 1s ease infinite;
        }

        @keyframes badgeBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        /* NAME INPUT */
        .name-input-container {
            margin: 20px 0;
        }

        .name-input-container input {
            padding: 12px 20px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            border-radius: 10px;
            width: 250px;
            text-align: center;
        }

        .name-input-container input:focus {
            outline: none;
            border-color: #764ba2;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }

        /* EMOJI PICKER */
        .emoji-picker {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .emoji-option {
            font-size: 2em;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 12px;
            border: 3px solid transparent;
            background: #f3f4f6;
            transition: all 0.2s ease;
            user-select: none;
        }

        .emoji-option:hover {
            background: #e5e7eb;
            transform: scale(1.15);
        }

        .emoji-option.selected-emoji {
            border-color: #667eea;
            background: #eef2ff;
            box-shadow: 0 0 12px rgba(102, 126, 234, 0.4);
            transform: scale(1.1);
        }

        /* NOT IN TOP 10 message */
        .not-in-top {
            font-size: 1.1em;
            color: #666;
            margin: 15px 0;
            padding: 12px;
            background: #f3f4f6;
            border-radius: 10px;
        }

        /* VICTORY SCREEN */
        .victory-content {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            padding: 40px 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            animation: victoryBounce 0.8s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(251, 191, 36, 0.4);
        }

        @keyframes victoryBounce {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }

        .victory-confetti {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .victory-emoji {
            font-size: 5em;
            animation: victoryEmoji 1s ease infinite;
            margin-bottom: 10px;
        }

        @keyframes victoryEmoji {
            0%, 100% { transform: scale(1) rotate(-5deg); }
            50% { transform: scale(1.2) rotate(5deg); }
        }

        .victory-title {
            font-size: 3em;
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            margin: 10px 0;
            font-weight: bold;
            letter-spacing: 3px;
        }

        .victory-subtitle {
            font-size: 1.2em;
            color: #1f2937;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .victory-stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
        }

        .victory-stat {
            background: rgba(255,255,255,0.3);
            padding: 20px;
            border-radius: 15px;
            min-width: 120px;
            backdrop-filter: blur(10px);
        }

        .victory-stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .victory-stat-label {
            font-size: 0.9em;
            color: #1f2937;
            margin-top: 5px;
            font-weight: 600;
        }

        .victory-button {
            font-size: 1.2em !important;
            padding: 15px 40px !important;
            animation: victoryButtonPulse 2s ease infinite;
        }

        @keyframes victoryButtonPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
            50% { transform: scale(1.05); box-shadow: 0 6px 25px rgba(0,0,0,0.3); }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           START BUTTON HAND POINTER HINT
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .start-hand-hint {
            position: absolute;
            font-size: 2.5em;
            pointer-events: none;
            z-index: 100;
            animation: handPointBounce 1.2s ease-in-out infinite;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        @keyframes handPointBounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(10px); }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           TUTORIAL OVERLAY - Centered Modal Style
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .tutorial-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .tutorial-overlay.show { display: flex; }

        .tutorial-content {
            background: rgba(255, 255, 255, 0.92);
            border-radius: 20px;
            padding: 30px 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
            animation: tutorialSlideIn 0.4s ease;
            backdrop-filter: blur(10px);
        }

        @keyframes tutorialSlideIn {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tutorial-step-indicator {
            color: #667eea;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .tutorial-icon {
            font-size: 4em;
            margin: 10px 0;
            animation: tutorialIconBounce 1.5s ease infinite;
        }

        @keyframes tutorialIconBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .tutorial-title {
            color: #1f2937;
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .tutorial-description {
            color: #4b5563;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 25px;
        }

        .tutorial-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tutorial-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tutorial-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .tutorial-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.6);
        }

        .tutorial-btn-secondary {
            background: #e5e7eb;
            color: #6b7280;
        }

        .tutorial-btn-secondary:hover {
            background: #d1d5db;
        }

        .tutorial-skip {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 0.9em;
            cursor: pointer;
            text-decoration: underline;
            padding: 5px 10px;
        }

        .tutorial-skip:hover {
            color: #6b7280;
        }

    
        /* Language Selector */
        .lang-selector {
            display: flex;
            gap: 6px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .lang-btn {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 6px;
            transition: all 0.2s;
            opacity: 0.5;
        }
        
        .lang-btn:hover { opacity: 0.8; transform: scale(1.1); }
        .lang-btn.active { opacity: 1; background: rgba(102, 126, 234, 0.15); }

    </style>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
</head>
<body>
    <div class="game-container">
        <h1>üéØ Grid Survivor</h1>
        <p class="subtitle">Scegli saggiamente e sopravvivi!</p>

        <!-- shield badge: appare nell'angolo in alto a destra quando scudo attivo -->
        <div class="shield-badge" id="shield-badge">üõ°Ô∏è SCUDO</div>

        <!-- sound toggle: angolo in alto a sinistra -->
        <div class="sound-toggle" id="sound-toggle" onclick="toggleSound()" title="Attiva/Disattiva Suoni">
            <span id="sound-icon">üîä</span>
        </div>

        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label" id="stat-score">Punteggio</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label" id="stat-cells">Caselle</div>
                <div class="stat-value" id="cells-eliminated">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label" id="stat-streak">Streak</div>
                <div class="stat-value" id="streak">0</div>
            </div>
            <div class="lives-container" id="lives"></div>
        </div>

        <div style="position: relative;">
            <div class="bonuses-container" id="bonuses"></div>
            <div id="bonus-scroll-hint" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                font-size: 0.8em;
                color: #1f2937;
                background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
                padding: 8px 16px;
                border-radius: 20px;
                box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
                display: none;
                pointer-events: none;
                z-index: 10;
                white-space: nowrap;
                font-weight: bold;
            " data-i18n="bonusScrollHint">
                üëà Scorri per vedere tutti üëâ
            </div>
        </div>

        <!-- Griglia + timer perimetrale + combo overlay -->
        <div class="grid-wrap" id="grid-wrap">
            <div class="grid-container" id="grid"></div>
            <div class="combo-indicator" id="combo"></div>
            <svg class="timer-perimeter" id="timer-perimeter">
                <rect id="timer-rect" x="3" y="3" width="100" height="100" rx="10" ry="10"/>
            </svg>
        </div>

        <div class="message info" id="message">Seleziona una casella per iniziare!</div>

        <div class="button-container">
            <div style="position: relative; display: inline-block;">
                <span class="start-hand-hint" id="start-hand-hint">üëá</span>
                <button class="primary" id="start-btn" onclick="startGame()" data-i18n="btnNewGame">Nuova Partita</button>
            </div>
            <button class="secondary" id="reset-btn" onclick="startGame()" style="display: none;" data-i18n="btnNewGame">Nuova Partita</button>
            <button class="secondary i18n-lb-btn" onclick="showLeaderboard()" style="padding: 10px 16px; font-size: 0.85em;">üèÜ <span class="i18n-lb-text">Classifica</span></button>
            
            <!-- Language Selector -->
            <div class="lang-selector">
                <button class="lang-btn" id="lang-it" onclick="changeLang('it')" title="Italiano">üáÆüáπ</button>
                <button class="lang-btn" id="lang-en" onclick="changeLang('en')" title="English">üá¨üáß</button>
            </div>
        </div>
    </div>

    <!-- GAME OVER -->
    <div class="game-over-overlay" id="game-over">
        <div class="game-over-content">
            <h2 data-i18n="goTitle">üí• GAME OVER!</h2>
            <div class="final-stats">
                <div><strong data-i18n="goFinalScore">Punteggio Finale:</strong> <span id="final-score">0</span></div>
                <div><strong data-i18n="goCellsEliminated">Caselle Eliminate:</strong> <span id="final-cells">0</span></div>
                <div><strong data-i18n="goBestStreak">Miglior Streak:</strong> <span id="final-streak">0</span></div>
            </div>

            <!-- Sezione per chi entra nella classifica -->
            <div id="save-section">
                <div class="name-input-container">
                    <input type="text" id="player-name" placeholder="" data-i18n-placeholder="goEnterName" maxlength="20" oninput="onNameInput()">
                </div>
                <div class="emoji-picker" id="emoji-picker"></div>
                <button class="primary i18n-save-btn" id="save-btn" onclick="saveToLeaderboard()" disabled><span class="i18n-save-text">Salva e Vedi Classifica</span></button>
            </div>

            <!-- Sezione per chi NON entra nella classifica -->
            <div id="no-save-section" style="display:none;">
                <div class="not-in-top" data-i18n="goNotInTop">Non sei entrato nei primi 10. Riprova!</div>
                <button class="primary" onclick="closeGameOver()" data-i18n="goRetry">Riprova</button>
            </div>
        </div>
    </div>

    <!-- LEADERBOARD -->
    <div class="game-over-overlay" id="leaderboard-overlay">
        <div class="game-over-content" style="max-width: 500px;">
            <h2 data-i18n="lbTitle">üèÜ CLASSIFICA</h2>
            <div id="firebase-status" style="font-size: 0.75em; color: #666; margin-bottom: 10px; text-align: center;"></div>
            <div id="leaderboard-list"></div>
            <button class="primary" onclick="closeLeaderboard()" style="width: 100%; max-width: 250px;" data-i18n="lbPlayAgain">Gioca Ancora</button>
        </div>
    </div>

    <!-- VICTORY -->
    <div class="game-over-overlay" id="victory-overlay">
        <div class="victory-content">
            <div class="victory-confetti" id="victory-confetti"></div>
            <div class="victory-emoji">üéâ</div>
            <h1 class="victory-title" data-i18n="vicTitle">VITTORIA!</h1>
            <p class="victory-subtitle" data-i18n="vicSubtitle">Hai completato tutte le 49 caselle!</p>
            <div class="victory-stats">
                <div class="victory-stat">
                    <div class="victory-stat-value" id="victory-score">0</div>
                    <div class="victory-stat-label" data-i18n="vicScore">Punteggio Finale</div>
                </div>
                <div class="victory-stat">
                    <div class="victory-stat-value" id="victory-streak">0</div>
                    <div class="victory-stat-label" data-i18n="vicStreak">Serie Migliore</div>
                </div>
            </div>
            <button class="primary victory-button i18n-vic-btn" onclick="closeVictory()">üèÜ <span class="i18n-vic-text">Salva e Vedi Classifica</span></button>
        </div>
    </div>

    <div class="bonus-notification" id="bonus-notification"></div>

    <div class="monster-popup" id="monster-popup">
        <div class="monster-container">
            <div class="monster-emoji" id="monster-emoji"></div>
            <div class="monster-text" id="monster-text">COLPITO!</div>
        </div>
    </div>

    <!-- MALUS POPUP -->
    <div class="malus-popup" id="malus-popup">
        <div class="malus-container">
            <span class="malus-emoji">üòà</span>
            <div class="malus-text" id="malus-text"></div>
        </div>
    </div>

    <!-- CARD MALUS POPUP -->
    <div class="card-malus-popup" id="card-malus-popup">
        <div class="card-malus-container">
            <div class="card-malus-emoji">üé¥</div>
            <h2 class="card-malus-title" data-i18n="cmTitle">CARTE MALEDETTE!</h2>
            <p class="card-malus-subtitle">
                <span data-i18n="cmSubtitle1">Scegli una carta...</span><br>
                <span data-i18n="cmSubtitle2">Perderai 1, 2 o 3 bonus!</span>
            </p>
            <div class="cards-container" id="cards-container">
                <div class="card" onclick="selectCard(0)">
                    <div class="card-back">?</div>
                </div>
                <div class="card" onclick="selectCard(1)">
                    <div class="card-back">?</div>
                </div>
                <div class="card" onclick="selectCard(2)">
                    <div class="card-back">?</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         TUTORIAL OVERLAY - Centered Modal
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div class="tutorial-overlay" id="tutorial-overlay">
        <div class="tutorial-content">
            <!-- Language selector in tutorial - TOP LEFT -->
            <div class="lang-selector" style="position: absolute; top: 15px; left: 15px; z-index: 100; width: fit-content;">
                <button class="lang-btn" id="tut-lang-it" onclick="changeLang('it')" title="Italiano">üáÆüáπ</button>
                <button class="lang-btn" id="tut-lang-en" onclick="changeLang('en')" title="English">üá¨üáß</button>
            </div>
            <button class="tutorial-skip" onclick="skipTutorial()" data-i18n="tutSkip">Salta Tutorial ‚úï</button>
            <div class="tutorial-step-indicator" id="tutorial-step-indicator">Step 1/8</div>
            <div class="tutorial-icon" id="tutorial-icon">üéØ</div>
            <h2 class="tutorial-title" id="tutorial-title">Benvenuto!</h2>
            <p class="tutorial-description" id="tutorial-description">Impara le basi in 8 semplici passi</p>
            <div class="tutorial-buttons">
                <button class="tutorial-btn tutorial-btn-primary" onclick="nextTutorialStep()">Avanti ‚Üí</button>
            </div>
        </div>
    </div>

    <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INTERNATIONALIZATION (i18n) - INLINE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    /**
     * Grid Survivor - Internationalization
     * Translations: Italian (it) + English (en)
     */
    
    // Detect browser language
    function detectBrowserLanguage() {
        const browserLang = navigator.language || navigator.userLanguage;
        // Se il browser √® in inglese (en, en-US, en-GB, etc.) ‚Üí inglese
        if (browserLang.toLowerCase().startsWith('en')) {
            return 'en';
        }
        // Default: italiano
        return 'it';
    }
    
    window.GridSurvivorI18N = {
        currentLang: localStorage.getItem('gridSurvivorLang') || detectBrowserLanguage(),
        
        strings: {
            it: {
                // Stats
                score: 'Punteggio',
                cells: 'Caselle',
                streak: 'Streak',
                
                // Buttons  
                btnNewGame: 'Nuova Partita',
                btnLeaderboard: 'Classifica',
                
                // Messages
                msgSelectCell: 'Seleziona una casella per iniziare!',
                
                // Bonus names (keep as keys for now - will translate in game)
                bonusShield: 'SCUDO',
                bonusTriple: 'TRIPLO',
                bonusSniper: 'SNIPER',
                bonusVision: 'VISIONE',
                bonusMagnet: 'MAGNETE',
                bonusLucky: 'FORTUNA',
                bonusLife: 'VITA+',
            bonusX2: 'x2 PUNTI',
            bonus750: '+750',
            bonus1500: '+1500',
            bonus3000: '+3000',
                
                // Tutorial
                tutSkip: 'Salta Tutorial ‚úï',
                tutBtnNext: 'Avanti ‚Üí',
                tutBtnStart: 'Inizia a Giocare! üöÄ',
            // Additional translations
            btnLeaderboardText: 'Classifica',
            btnSaveLeaderboard: 'Salva e Vedi Classifica',
            msgSelectInstructions: 'Seleziona una casella!',
            msgTimeExpired: '‚è∞ Tempo scaduto! Non hai selezionato nessuna casella!',
            msgCellSelected: 'Casella selezionata! Attendi la rivelazione...',
            msgLastCell: 'üéâ Ultima casella! Hai vinto!',
            
            // Bonus notifications
            notifTriple: 'TRIPLO',
            notifTripleDesc: 'Elimina 3 caselle sicure dalla griglia!',
            notifSniper: 'SNIPER',
            notifSniperDesc: 'Elimina 1 casella rossa garantita!',
            notifVision: 'VISIONE',
            notifVisionDesc: 'Rivela 3 caselle sicure per 5 secondi!',
            notifMagnet: 'MAGNETE',
            notifMagnetDesc: 'Rivela tutti i bonus per 3 secondi!',
            notifLucky: 'FORTUNA',
            notifLuckyDesc: 'Dimezza le celle rosse al prossimo turno!',
            notifX2: 'x2 PUNTI',
            notifX2Desc: 'Doppi punti per i prossimi 3 turni!',
            notif750: '+750 PUNTI',
            notif750Desc: 'Guadagni 750 punti immediati!',
            notif1500: '+1500 PUNTI',
            notif1500Desc: 'Guadagni 1500 punti immediati!',
            notif3000: '+3000 PUNTI - JACKPOT!',
            notif3000Desc: 'Guadagni 3000 punti immediati!',
            notifLifeDesc: 'Guadagni una vita extra!',
            
            // Victory screen
            vicScore: 'Punteggio Finale',
            vicStreak: 'Serie Migliore',
            
            // Game Over
            goEnterName: 'Inserisci il tuo nome...',
            
            // Tutorial
            tutTitle1: 'Benvenuto!',
            tutDesc1: 'Impara le basi in 8 semplici passi',
            tutTitle2: 'Obiettivo',
            tutDesc2: 'Elimina tutte le 49 caselle senza perdere tutte le vite!',
            tutTitle3: 'Timer',
            tutDesc3: 'Hai 10 secondi per selezionare ogni casella. Il perimetro si riempie progressivamente.',
            tutTitle4: 'Zona Rossa',
            tutDesc4: 'Ad ogni turno alcune caselle diventano rosse. Se le selezioni, perdi una vita!',
            tutTitle5: 'Vite',
            tutDesc5: 'Inizi con 3 vite ‚ù§Ô∏è. Quando finiscono √® Game Over!',
            tutTitle6: 'Bonus',
            tutDesc6: '10 bonus nascosti nella griglia ti aiuteranno: scudi, visioni, magneti e altro!',
            tutTitle7: 'Malus',
            tutDesc7: 'Attenzione ai malus! Possono raddoppiare le celle rosse o farti perdere bonus.',
            tutTitle8: 'Classifica',
            tutDesc8: 'Completa il gioco e salva il tuo punteggio nella classifica globale!',
            
            // Bonus descriptions
            descShield: 'Ti salva dalla prossima colpita',
            descTriple: 'Elimina 3 caselle sicure',
            descSniper: 'Elimina 1 casella rossa garantita',
            descVision: 'Rivela caselle sicure per 5 secondi',
            descMagnet: 'Rivela tutti i bonus per 3 secondi',
            descLucky: 'Dimezza le celle rosse al prossimo turno',
            descLife: 'Guadagna una vita extra',
            descX2: 'Doppi punti per 3 turni',
            desc750: '+750 punti immediati',
            desc1500: '+1500 punti immediati',
            desc3000: '+3000 punti immediati - JACKPOT!',
            
            // Malus
            malusName: 'SFORTUNA',
            malusDesc: 'Raddoppia le celle rosse al prossimo turno',
            cardMalusName: 'CARTE MALEDETTE',
            cardMalusDesc: 'Scegli una carta e perdi 1-3 bonus',
            
            // Monsters
            monster1: 'COLPITO!',
            monster2: 'BECCATO!',
            monster3: 'BOOOOM!',
            monster4: 'VAMPIRO!',
            monster5: 'ROBOT MALVAGIO!',
            monster6: 'ECLISSI NERA!',
            monster7: 'KRAKEN!',
            monster8: 'SCHELETRO!',
            monster9: 'FIAMME!',
            monster10: 'FULMINE!',
            
            // Title
            title: 'Grid Survivor - Sopravvivi alla Griglia!',
            
            // Game messages
            msgMemorizeBonuses: 'üéÅ MEMORIZZA I BONUS!',
            msgSelectNext: 'Seleziona la prossima casella!',
            msgTimeUp: '‚è∞ Tempo scaduto!',
            msgPointsWait: '+{points} punti! Attendi la rivelazione...',
            msgShieldSaved: 'üõ°Ô∏è Lo scudo ti ha salvato! Una delle caselle rosse era la tua!',
            msgLifelineSurvived: 'üÜò LIFELINE! Una delle tue caselle √® sopravvissuta!',
            msgLifelineFailed: 'üí• LIFELINE FALLITO! Tutte le caselle sono cadute!',
            msgOhNo: 'üí• OH NO! Una delle {count} caselle era la tua!',
            msgSafe: '‚úÖ Salvo! Nessuna delle {count} caselle era la tua. Continua!',
            msgLifeLost: 'üíî Vita persa! Ne rimangono {lives}. Attento!',
            msgBonusesLost: 'üíÄ Hai perso {count} bonus!',
            msgNoBonusToLose: 'üòÖ Nessun bonus da perdere!',
            
            // Game Over screen
            goTitle: 'üí• GAME OVER!',
            goFinalScore: 'Punteggio Finale:',
            goCellsEliminated: 'Caselle Eliminate:',
            goBestStreak: 'Miglior Streak:',
            goNotInTop: 'Non sei entrato nei primi 10. Riprova!',
            goRetry: 'Riprova',
            
            // Leaderboard
            lbTitle: 'üèÜ CLASSIFICA',
            lbPlayAgain: 'Gioca Ancora',
            
            // Victory
            vicTitle: 'VITTORIA!',
            vicSubtitle: 'Hai completato tutte le 49 caselle!',
            
            // Card Malus popup
            cmTitle: 'CARTE MALEDETTE!',
            cmSubtitle1: 'Scegli una carta...',
            cmSubtitle2: 'Perderai 1, 2 o 3 bonus!',
            
            // Bonus scroll hint
            bonusScrollHint: 'üëà Scorri per vedere tutti üëâ',
            
            // Bonus activation messages
            bonusShieldUsed: 'SCUDO USATO!',
            bonusShieldUsedDesc: 'Sei stato salvato!',
            bonusLifelineSaved: 'LIFELINE!',
            bonusLifelineSavedDesc: 'Una casella ti ha salvato!',
            bonusExtraLife: 'VITA EXTRA! ‚ù§Ô∏è',
            bonusShieldActive: 'SCUDO ATTIVO! üòà',
            bonusShieldActiveDesc: 'Sarai salvato al prossimo colpo',
            bonusLifeFull: 'VITA PIENA! ‚ù§Ô∏è',
            bonusLifeFullDesc: 'Hai gi√† il massimo delle vite!',
            
            // Malus popup messages
            malusPopupText: 'Bonus <span class="malus-highlight">Sfortuna</span>...<br>solo <span class="malus-highlight">{count} caselle libere</span>',
            
            // Streak/Combo messages
            streakLegendary: 'üî• LEGGENDARIO! x{count} üî•',
            streakIncredible: '‚ö° INCREDIBILE! x{count} ‚ö°',
            streakFantastic: '‚ú® FANTASTICO! x{count} ‚ú®',
            streakCombo: 'üéØ COMBO x{count}!',
            
            // Leaderboard messages
            lbLocal: 'üíæ Classifica Locale (solo questo dispositivo)',
            lbEmpty: 'Nessun punteggio ancora. Sii il primo!',
            lbLoading: '‚è≥ Caricamento classifica',
            lbOnline: 'Classifica Online Globale',
            lbError: 'Errore caricamento online - Mostrando classifica locale',
        },
            
            en: {
                // Stats
                score: 'Score',
                cells: 'Cells', 
                streak: 'Streak',
                
                // Buttons
                btnNewGame: 'New Game',
                btnLeaderboard: 'Leaderboard',
                
                // Messages
                msgSelectCell: 'Select a cell to start!',
                
                // Bonus names
                bonusShield: 'SHIELD',
                bonusTriple: 'TRIPLE',
                bonusSniper: 'SNIPER',
                bonusVision: 'VISION',
                bonusMagnet: 'MAGNET',
                bonusLucky: 'LUCKY',
                bonusLife: 'LIFE+',
            bonusX2: 'x2 POINTS',
            bonus750: '+750',
            bonus1500: '+1500',
            bonus3000: '+3000',
                
                // Tutorial
                tutSkip: 'Skip Tutorial ‚úï',
                tutBtnNext: 'Next ‚Üí',
                tutBtnStart: 'Start Playing! üöÄ',
            // Additional translations
            btnLeaderboardText: 'Leaderboard',
            btnSaveLeaderboard: 'Save & View Leaderboard',
            msgSelectInstructions: 'Select a cell!',
            msgTimeExpired: '‚è∞ Time expired! You did not select any cell!',
            msgCellSelected: 'Cell selected! Wait for reveal...',
            msgLastCell: 'üéâ Last cell! You won!',
            
            // Bonus notifications
            notifTriple: 'TRIPLE',
            notifTripleDesc: 'Eliminate 3 safe cells from the grid!',
            notifSniper: 'SNIPER',
            notifSniperDesc: 'Eliminate 1 guaranteed red cell!',
            notifVision: 'VISION',
            notifVisionDesc: 'Reveal 3 safe cells for 5 seconds!',
            notifMagnet: 'MAGNET',
            notifMagnetDesc: 'Reveal all bonuses for 3 seconds!',
            notifLucky: 'LUCKY',
            notifLuckyDesc: 'Halve the red cells in the next turn!',
            notifX2: 'x2 POINTS',
            notifX2Desc: 'Double points for the next 3 turns!',
            notif750: '+750 POINTS',
            notif750Desc: 'Gain 750 points immediately!',
            notif1500: '+1500 POINTS',
            notif1500Desc: 'Gain 1500 points immediately!',
            notif3000: '+3000 POINTS - JACKPOT!',
            notif3000Desc: 'Gain 3000 points immediately!',
            notifLifeDesc: 'Gain an extra life!',
            
            // Victory screen
            vicScore: 'Final Score',
            vicStreak: 'Best Streak',
            
            // Game Over
            goEnterName: 'Enter your name...',
            
            // Tutorial
            tutTitle1: 'Welcome!',
            tutDesc1: 'Learn the basics in 8 simple steps',
            tutTitle2: 'Objective',
            tutDesc2: 'Eliminate all 49 cells without losing all lives!',
            tutTitle3: 'Timer',
            tutDesc3: 'You have 10 seconds to select each cell. The perimeter fills progressively.',
            tutTitle4: 'Red Zone',
            tutDesc4: 'Each turn some cells turn red. If you select them, you lose a life!',
            tutTitle5: 'Lives',
            tutDesc5: 'You start with 3 lives ‚ù§Ô∏è. When they run out it\'s Game Over!',
            tutTitle6: 'Bonuses',
            tutDesc6: '10 hidden bonuses in the grid will help you: shields, visions, magnets and more!',
            tutTitle7: 'Maluses',
            tutDesc7: 'Beware of maluses! They can double red cells or make you lose bonuses.',
            tutTitle8: 'Leaderboard',
            tutDesc8: 'Complete the game and save your score on the global leaderboard!',
            
            // Bonus descriptions
            descShield: 'Saves you from the next hit',
            descTriple: 'Eliminate 3 safe cells',
            descSniper: 'Eliminate 1 guaranteed red cell',
            descVision: 'Reveal safe cells for 5 seconds',
            descMagnet: 'Reveal all bonuses for 3 seconds',
            descLucky: 'Halve red cells in next turn',
            descLife: 'Gain an extra life',
            descX2: 'Double points for 3 turns',
            desc750: '+750 points immediately',
            desc1500: '+1500 points immediately',
            desc3000: '+3000 points immediately - JACKPOT!',
            
            // Malus
            malusName: 'BAD LUCK',
            malusDesc: 'Double red cells in next turn',
            cardMalusName: 'CURSED CARDS',
            cardMalusDesc: 'Choose a card and lose 1-3 bonuses',
            
            // Monsters
            monster1: 'HIT!',
            monster2: 'CAUGHT!',
            monster3: 'BOOOOM!',
            monster4: 'VAMPIRE!',
            monster5: 'EVIL ROBOT!',
            monster6: 'BLACK ECLIPSE!',
            monster7: 'KRAKEN!',
            monster8: 'SKELETON!',
            monster9: 'FLAMES!',
            monster10: 'LIGHTNING!',
            
            // Title
            title: 'Grid Survivor - Survive the Grid!',
            
            // Game messages
            msgMemorizeBonuses: 'üéÅ MEMORIZE BONUSES!',
            msgSelectNext: 'Select the next cell!',
            msgTimeUp: '‚è∞ Time is up!',
            msgPointsWait: '+{points} points! Wait for reveal...',
            msgShieldSaved: 'üõ°Ô∏è The shield saved you! One of the red cells was yours!',
            msgLifelineSurvived: 'üÜò LIFELINE! One of your cells survived!',
            msgLifelineFailed: 'üí• LIFELINE FAILED! All cells fell!',
            msgOhNo: 'üí• OH NO! One of the {count} cells was yours!',
            msgSafe: '‚úÖ Safe! None of the {count} cells was yours. Continue!',
            msgLifeLost: 'üíî Life lost! {lives} remaining. Be careful!',
            msgBonusesLost: 'üíÄ You lost {count} bonuses!',
            msgNoBonusToLose: 'üòÖ No bonuses to lose!',
            
            // Game Over screen
            goTitle: 'üí• GAME OVER!',
            goFinalScore: 'Final Score:',
            goCellsEliminated: 'Cells Eliminated:',
            goBestStreak: 'Best Streak:',
            goNotInTop: 'You didn\'t make it to the top 10. Try again!',
            goRetry: 'Try Again',
            
            // Leaderboard
            lbTitle: 'üèÜ LEADERBOARD',
            lbPlayAgain: 'Play Again',
            
            // Victory
            vicTitle: 'VICTORY!',
            vicSubtitle: 'You completed all 49 cells!',
            
            // Card Malus popup
            cmTitle: 'CURSED CARDS!',
            cmSubtitle1: 'Choose a card...',
            cmSubtitle2: 'You will lose 1, 2 or 3 bonuses!',
            
            // Bonus scroll hint
            bonusScrollHint: 'üëà Scroll to see all üëâ',
            
            // Bonus activation messages
            bonusShieldUsed: 'SHIELD USED!',
            bonusShieldUsedDesc: 'You were saved!',
            bonusLifelineSaved: 'LIFELINE!',
            bonusLifelineSavedDesc: 'A cell saved you!',
            bonusExtraLife: 'EXTRA LIFE! ‚ù§Ô∏è',
            bonusShieldActive: 'SHIELD ACTIVE! üòà',
            bonusShieldActiveDesc: 'You will be saved on the next hit',
            bonusLifeFull: 'LIFE FULL! ‚ù§Ô∏è',
            bonusLifeFullDesc: 'You already have maximum lives!',
            
            // Malus popup messages
            malusPopupText: 'Bonus <span class="malus-highlight">Bad Luck</span>...<br>only <span class="malus-highlight">{count} free cells</span>',
            
            // Streak/Combo messages
            streakLegendary: 'üî• LEGENDARY! x{count} üî•',
            streakIncredible: '‚ö° INCREDIBLE! x{count} ‚ö°',
            streakFantastic: '‚ú® FANTASTIC! x{count} ‚ú®',
            streakCombo: 'üéØ COMBO x{count}!',
            
            // Leaderboard messages
            lbLocal: 'üíæ Local Leaderboard (this device only)',
            lbEmpty: 'No scores yet. Be the first!',
            lbLoading: '‚è≥ Loading leaderboard',
            lbOnline: 'Global Online Leaderboard',
            lbError: 'Online loading error - Showing local leaderboard',
        }
        },
        
        t: function(key) {
            return this.strings[this.currentLang][key] || this.strings['it'][key] || key;
        },
        
        changeLang: function(lang) {
            this.currentLang = lang;
            localStorage.setItem('gridSurvivorLang', lang);
            location.reload();
        }
    };
    
    // Shorthand
    window.t = (key) => window.GridSurvivorI18N.t(key);
    
    // Helper for template strings with parameters
    window.tpl = (key, params) => {
        let str = t(key);
        Object.keys(params).forEach(k => {
            str = str.replace(new RegExp(`\\{${k}\\}`, 'g'), params[k]);
        });
        return str;
    };
    
    
    // Helper: translate bonus/malus object
    function tb(obj) {
        if (!obj) return obj;
        return {
            ...obj,
            name: t(obj.name),
            description: t(obj.description)
        };
    }
    
    // Helper: translate monster
    function tmon(monster) {
        if (!monster) return monster;
        return {
            ...monster,
            text: t(monster.text)
        };
    }

    // Wrapper function for language change (called by onclick)
    function changeLang(lang) {
        if (window.GridSurvivorI18N && typeof GridSurvivorI18N.changeLang === 'function') {
            GridSurvivorI18N.changeLang(lang);
        } else {
            console.error('GridSurvivorI18N not ready');
        }
    }

    


    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FIREBASE CONFIGURATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const firebaseConfig = {
        apiKey: "AIzaSyDamBv3u0gvX6zdA7w0LUL75JTRlgt6MtU",
        authDomain: "grid-survivor.firebaseapp.com",
        databaseURL: "https://grid-survivor-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "grid-survivor",
        storageBucket: "grid-survivor.firebasestorage.app",
        messagingSenderId: "65681965353",
        appId: "1:65681965353:web:a5ff81cfcbc2657308f738"
    };

    // Inizializza Firebase
    let database = null;
    let useOnlineLeaderboard = false;

    try {
        firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        useOnlineLeaderboard = true;
        console.log('‚úÖ Firebase connected - online leaderboard active');
    } catch (error) {
        // Silently fallback to local leaderboard
        useOnlineLeaderboard = false;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TUTORIAL SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let currentTutorialStep = 0;
    let tutorialCompleted = localStorage.getItem('tutorialCompleted') === 'true';

    const tutorialSteps = [
        { icon: 'üéØ', title: 'tutTitle1', description: 'tutDesc1' },
        { icon: 'üéÆ', title: 'tutTitle2', description: 'tutDesc2' },
        { icon: '‚è±Ô∏è', title: 'tutTitle3', description: 'tutDesc3' },
        { icon: 'üü•', title: 'tutTitle4', description: 'tutDesc4' },
        { icon: '‚ù§Ô∏è', title: 'tutTitle5', description: 'tutDesc5' },
        { icon: 'üéÅ', title: 'tutTitle6', description: 'tutDesc6' },
        { icon: 'üòà', title: 'tutTitle7', description: 'tutDesc7' },
        { icon: 'üèÜ', title: 'tutTitle8', description: 'tutDesc8' }
    ];

    function showTutorial() {
        currentTutorialStep = 0;
        document.getElementById('tutorial-overlay').classList.add('show');
        renderTutorialStep();
    }

    function renderTutorialStep() {
        const step = tutorialSteps[currentTutorialStep];
        const totalSteps = tutorialSteps.length;
        
        document.getElementById('tutorial-step-indicator').textContent = `Step ${currentTutorialStep + 1}/${totalSteps}`;
        document.getElementById('tutorial-icon').textContent = step.icon;
        document.getElementById('tutorial-title').textContent = t(step.title);
        document.getElementById('tutorial-description').textContent = t(step.description);
        
        // Aggiorna pulsante
        const buttonsContainer = document.querySelector('.tutorial-buttons');
        const isLastStep = currentTutorialStep === totalSteps - 1;
        
        buttonsContainer.innerHTML = isLastStep
            ? `<button class="tutorial-btn tutorial-btn-primary" onclick="completeTutorial()">${t('tutBtnStart')}</button>`
            : `<button class="tutorial-btn tutorial-btn-primary" onclick="nextTutorialStep()">${t('tutBtnNext')}</button>`;
    }

    function nextTutorialStep() {
        if (currentTutorialStep < tutorialSteps.length - 1) {
            currentTutorialStep++;
            renderTutorialStep();
        }
    }

    function skipTutorial() {
        completeTutorial();
    }

    function completeTutorial() {
        localStorage.setItem('tutorialCompleted', 'true');
        tutorialCompleted = true;
        document.getElementById('tutorial-overlay').classList.remove('show');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GAME CODE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚îÄ‚îÄ‚îÄ AudioContext per i suoni dei personaggi ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let audioCtx = null;
    function getAudioCtx() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
    }

    // Suono di tick del timer
    function playTickSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(1200, now);
        g.gain.setValueAtTime(0.15, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        o.start(now);
        o.stop(now + 0.05);
    }

    // Suono perdita vita - tono scendente drammatico
    function playLifeLostSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(600, now);
        o.frequency.exponentialRampToValueAtTime(150, now + 0.4);
        g.gain.setValueAtTime(0.3, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        o.start(now);
        o.stop(now + 0.4);
    }

    // Suono attivazione scudo - tono crescente protettivo
    function playShieldSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(400, now);
        o.frequency.exponentialRampToValueAtTime(800, now + 0.2);
        g.gain.setValueAtTime(0.25, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        o.start(now);
        o.stop(now + 0.3);
    }

    // Toggle audio on/off
    function toggleSound() {
        soundEnabled = !soundEnabled;
        document.getElementById('sound-icon').textContent = soundEnabled ? 'üîä' : 'üîá';
    }

    // Risata malefice del Malus: 3 note discendenti distorte + rumore
    function playEvilLaughSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;

        // Rumore di fondo basso e cupo
        const bufLen = ctx.sampleRate * 1.2;
        const buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < bufLen; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.6));
        const noise = ctx.createBufferSource(); noise.buffer = buf;
        const nf = ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.value = 250;
        const ng = ctx.createGain(); ng.gain.setValueAtTime(0.15, now); ng.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
        noise.connect(nf); nf.connect(ng); ng.connect(ctx.destination);
        noise.start(now);

        // 3 "ha" distortati: note gravi che scendono, con distorsione (sawtooth)
        const notes = [
            { freq: 160, start: 0,    dur: 0.25 },
            { freq: 130, start: 0.28, dur: 0.25 },
            { freq: 105, start: 0.56, dur: 0.35 }
        ];
        notes.forEach(({ freq, start, dur }) => {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            const dist = ctx.createWaveShaper();
            // curva di distorsione
            const curve = new Float32Array(256);
            for (let i = 0; i < 256; i++) {
                const x = (i * 2) / 256 - 1;
                curve[i] = (Math.PI + 200) * x / (Math.PI + 200 * Math.abs(x));
            }
            dist.curve = curve;
            dist.oversample = '4x';

            o.connect(dist); dist.connect(g); g.connect(ctx.destination);
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(freq, now + start);
            o.frequency.exponentialRampToValueAtTime(freq * 0.7, now + start + dur);
            g.gain.setValueAtTime(0, now + start);
            g.gain.linearRampToValueAtTime(0.3, now + start + 0.04);
            g.gain.exponentialRampToValueAtTime(0.001, now + start + dur);
            o.start(now + start);
            o.stop(now + start + dur);
        });
    }

    // Genera un suono sintetizzato con parametri diversi per ogni personaggio
    function playMonsterSound(monsterIndex) {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;

        // Parametri unici per ciascuno dei 10 personaggi
        const sounds = [
            // 0 üëæ ‚Äî bip elettronico acuto
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'square'; o.frequency.setValueAtTime(880, now);
                o.frequency.exponentialRampToValueAtTime(440, now + 0.15);
                g.gain.setValueAtTime(0.3, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                o.start(now); o.stop(now + 0.3);
            },
            // 1 üëª ‚Äî gemito fantasma (rumore filtrato)
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.4, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.15));
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 300; f.Q.value = 3;
                const g = ctx.createGain(); g.gain.value = 0.4;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 2 üéÉ ‚Äî basso profondo pulsante
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'sine'; o.frequency.setValueAtTime(80, now);
                o.frequency.exponentialRampToValueAtTime(40, now + 0.4);
                g.gain.setValueAtTime(0.5, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                o.start(now); o.stop(now + 0.5);
            },
            // 3 ü¶á ‚Äî strillo acuto rapido
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'sawtooth'; o.frequency.setValueAtTime(1200, now);
                o.frequency.exponentialRampToValueAtTime(200, now + 0.25);
                g.gain.setValueAtTime(0.25, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                o.start(now); o.stop(now + 0.25);
            },
            // 4 ü§ñ ‚Äî beep metallico doppio
            () => {
                [0, 0.12].forEach(delay => {
                    const o = ctx.createOscillator(); const g = ctx.createGain();
                    o.connect(g); g.connect(ctx.destination);
                    o.type = 'square'; o.frequency.value = 660;
                    g.gain.setValueAtTime(0, now + delay);
                    g.gain.linearRampToValueAtTime(0.2, now + delay + 0.03);
                    g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.13);
                    o.start(now + delay); o.stop(now + delay + 0.13);
                });
            },
            // 5 üåë ‚Äî sussurro oscuro (noise grave)
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.25));
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 150;
                const g = ctx.createGain(); g.gain.value = 0.35;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 6 üêô ‚Äî gorgoglio acquatico
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.35, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.3 * Math.sin(i * 0.05);
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 500; f.Q.value = 1.5;
                const g = ctx.createGain(); g.gain.value = 0.4;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 7 üíÄ ‚Äî nota funebre lenta
            () => {
                [0, 0.18, 0.36].forEach((delay, i) => {
                    const o = ctx.createOscillator(); const g = ctx.createGain();
                    o.connect(g); g.connect(ctx.destination);
                    o.type = 'sine'; o.frequency.value = [220, 185, 165][i];
                    g.gain.setValueAtTime(0, now + delay);
                    g.gain.linearRampToValueAtTime(0.2, now + delay + 0.04);
                    g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.17);
                    o.start(now + delay); o.stop(now + delay + 0.17);
                });
            },
            // 8 üî• ‚Äî crepitio di fuoco
            () => {
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.08));
                const src = ctx.createBufferSource(); src.buffer = buf;
                const f = ctx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 800;
                const g = ctx.createGain(); g.gain.value = 0.3;
                src.connect(f); f.connect(g); g.connect(ctx.destination);
                src.start(now);
            },
            // 9 ‚ö° ‚Äî zap elettrico
            () => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.type = 'sawtooth'; o.frequency.setValueAtTime(400, now);
                o.frequency.exponentialRampToValueAtTime(2000, now + 0.08);
                o.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                g.gain.setValueAtTime(0.3, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                o.start(now); o.stop(now + 0.2);
            }
        ];
        if (sounds[monsterIndex]) sounds[monsterIndex]();
    }

    // ‚îÄ‚îÄ‚îÄ Costanti ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const GRID_SIZE = 7;
    const TIMER_DURATION = 8;          // pi√π tempo per giocare con calma
    const BASE_POINTS = 10;
    const POINTS_MULTIPLIER = 1.5;
    const CAP_STREAK = 10;
    const BASE_BONUS = 50;
    const BONUS_INCREMENT = 5;
    const MAX_BONUSES_PER_GAME = 10;

    const BONUS_TYPES = [
        { id: 'shield',        name: 'bonusShield',    icon: 'üõ°Ô∏è',  description: 'descShield' },
        { id: 'eliminate3',    name: 'bonusTriple',   icon: 'üí£',  description: 'descTriple' },
        { id: 'sniper',        name: 'bonusSniper',   icon: 'üéØ',  description: 'descSniper' },
        { id: 'vision',        name: 'bonusVision',  icon: 'üëÅÔ∏è',  description: 'descVision' },
        { id: 'magnet',        name: 'bonusMagnet',  icon: 'üß≤',  description: 'descMagnet' },
        { id: 'lucky',         name: 'bonusLucky',  icon: 'üé≤',  description: 'descLucky' },
        { id: 'extraLife',     name: 'bonusLife',    icon: '‚ù§Ô∏è',  description: 'descLife' }
    ];

    // Bonus punti: uno di questi sostituisce doublePoints in modo casuale
    const POINT_BONUSES = [
        { id: 'doublePoints',  name: 'bonusX2', icon: 'üí∞',  description: 'descX2' },
        { id: 'points750',     name: 'bonus750',    icon: 'üíµ',  description: 'desc750' },
        { id: 'points1500',    name: 'bonus1500',   icon: 'üí∏',  description: 'desc1500' },
        { id: 'points3000',    name: 'bonus3000',   icon: 'üíé',  description: 'desc3000' }
    ];

    // Malus: truffa nascosta, 50% di possibilit√† di apparire nella partita
    const MALUS_TRAP = { id: 'malus', name: 'malusName', icon: 'üòà', description: 'malusDesc' };
    const CARD_MALUS = { id: 'cardMalus', name: 'cardMalusName', icon: 'üé¥', description: 'cardMalusDesc' };

    // 10 personaggi con emoji unici
    const MONSTERS = [
        { emoji: 'üëæ', text: 'monster1' },
        { emoji: 'üëª', text: 'monster2' },
        { emoji: 'üéÉ', text: 'monster3' },
        { emoji: 'ü¶á', text: 'monster4' },
        { emoji: 'ü§ñ', text: 'monster5' },
        { emoji: 'üåë', text: 'monster6' },
        { emoji: 'üêô', text: 'monster7' },
        { emoji: 'üíÄ', text: 'monster8' },
        { emoji: 'üî•', text: 'monster9' },
        { emoji: '‚ö°', text: 'monster10' }
    ];

    // Emoji disponibili per il profilo nella classifica
    const PROFILE_EMOJIS = ['üòé', 'üèÜ', '‚öîÔ∏è', 'üéÆ', 'üåü', 'ü¶Ö', 'üêâ', 'üí™', 'üéØ', 'üî•', 'üëë', '‚≠ê', 'üíé', 'üöÄ', '‚ö°'];

    // ‚îÄ‚îÄ‚îÄ Stato del gioco ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let gameState = {
        score: 0,
        cellsEliminated: 0,
        currentStreak: 0,
        bestStreak: 0,
        selectedCell: null,
        eliminatedCells: new Set(),
        timerInterval: null,
        timeRemaining: TIMER_DURATION,
        isGameActive: false,
        roundNumber: 0,
        bonusCells: new Map(),
        collectedBonuses: [],
        activeShield: false,
        doublePointsRemaining: 0,
        visionActive: false,
        safeCells: [],
        isProcessingReveal: false,
        dangerZone: { row: 0, col: 0, dir: { dr: 1, dc: 1 } }, // epicentro + direzione
        lifelineActive: false,   // lifeline attiva per questo round
        lifelineCells: [],       // le 5 caselle accese dal lifeline
        lives: 3,                // vite disponibili
        pointsStreak: 0,         // caselle consecutive senza colpita (esponente punti)
        isPaused: false,         // true durante le notifiche bonus (blocca tutto)
        luckyActive: false,      // dimezza le celle rosse per 1 turno
        malusActive: false,      // doppio rossi al prossimo turno
        malusFound: false,       // trovato questo turno, si attiva al prossimo
        allBonusesInGame: null,  // snapshot dei bonus reali della partita
        gameStarted: false,      // true dopo "Nuova Partita"
        bonusHintShown: false,   // hint scroll mostrato solo la prima volta
        victoryAchieved: false   // true se ha completato tutte le 49 caselle
    };

    let selectedProfileEmoji = PROFILE_EMOJIS[0]; // emoji di default
    let soundEnabled = true; // controllo audio globale

    // ‚îÄ‚îÄ‚îÄ Inizializzazione griglia ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function initGrid() {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';
        gameState.bonusCells = new Map();

        // Celle interni: escludi il perimetro (riga 0/6, colonna 0/6)
        const interiorPositions = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const row = Math.floor(i / GRID_SIZE);
            const col = i % GRID_SIZE;
            if (row > 0 && row < GRID_SIZE - 1 && col > 0 && col < GRID_SIZE - 1) {
                interiorPositions.push(i);
            }
        }
        shuffle(interiorPositions);

        // Bonus diversi da extraLife
        const regularBonuses = BONUS_TYPES.filter(b => b.id !== 'extraLife');
        const extraLifeBonus = BONUS_TYPES.find(b => b.id === 'extraLife');
        
        // Scegli un bonus punti casuale da POINT_BONUSES (40% x2, 20% altri)
        let selectedPointBonus;
        const pointRoll = Math.random();
        if (pointRoll < 0.40) {
            selectedPointBonus = POINT_BONUSES[0]; // 40% x2 PUNTI
        } else if (pointRoll < 0.60) {
            selectedPointBonus = POINT_BONUSES[1]; // 20% +750
        } else if (pointRoll < 0.80) {
            selectedPointBonus = POINT_BONUSES[2]; // 20% +1500
        } else {
            selectedPointBonus = POINT_BONUSES[3]; // 20% +3000 JACKPOT!
        }
        
        // Crea pool di bonus regolari + il bonus punti scelto
        const bonusPool = [...regularBonuses, selectedPointBonus];
        
        // Probabilit√† vite extra: 50% per 1, 20% per 2, 5% per 3, 25% per 0
        const rand = Math.random();
        let extraLivesCount;
        if (rand < 0.25) extraLivesCount = 0;       // 25% nessuna vita extra
        else if (rand < 0.75) extraLivesCount = 1;  // 50% una vita (0.25 + 0.50)
        else if (rand < 0.95) extraLivesCount = 2;  // 20% due vite (0.75 + 0.20)
        else extraLivesCount = 3;                    // 5% tre vite (restante)
        
        // Aggiungi le vite extra nelle prime posizioni (se ce ne sono)
        for (let i = 0; i < extraLivesCount; i++) {
            gameState.bonusCells.set(interiorPositions[i], extraLifeBonus);
        }

        // Riempi il resto con bonus dal pool (regolari + 1 bonus punti)
        // Crea un pool pi√π grande per evitare troppi duplicati consecutivi
        const expandedPool = [];
        // Aggiungi ogni bonus 1-2 volte per distribuire meglio
        bonusPool.forEach(bonus => {
            expandedPool.push(bonus);
            // 70% chance di aggiungere una seconda copia
            if (Math.random() < 0.7) {
                expandedPool.push(bonus);
            }
        });
        shuffle(expandedPool);
        
        // Riempi gli slot rimanenti
        for (let b = extraLivesCount; b < MAX_BONUSES_PER_GAME; b++) {
            const poolIndex = (b - extraLivesCount) % expandedPool.length;
            gameState.bonusCells.set(interiorPositions[b], expandedPool[poolIndex]);
        }

        // MALUS: Solo UNO per partita! Scegli casualmente tra Sfortuna e Carte
        const malusRoll = Math.random();
        if (malusRoll < 0.30) {
            // 30% Malus Sfortuna (ultimo slot)
            gameState.bonusCells.set(interiorPositions[MAX_BONUSES_PER_GAME - 1], MALUS_TRAP);
        } else if (malusRoll < 0.60 && extraLivesCount < MAX_BONUSES_PER_GAME - 1) {
            // 30% Card Malus (penultimo slot) - solo se non occupato da vite extra
            gameState.bonusCells.set(interiorPositions[MAX_BONUSES_PER_GAME - 2], CARD_MALUS);
        }
        // 40% nessun malus (malusRoll >= 0.60)

        // Salva snapshot dei bonus reali della partita (esclusi malus) per la barra
        gameState.allBonusesInGame = [];
        gameState.bonusCells.forEach((bonus) => {
            if (bonus.id !== 'malus' && bonus.id !== 'cardMalus') {
                gameState.allBonusesInGame.push({ id: bonus.id, name: bonus.name, icon: bonus.icon });
            }
        });

        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.dataset.index = i;
            cell.addEventListener('click', () => selectCell(i));
            grid.appendChild(cell);
        }
        updateBonusDisplay();
        initDangerZone();
    }

    function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // ‚îÄ‚îÄ‚îÄ Zona di pericolo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // L'epicentro si muove ogni round in una direzione diagonale e "rimbalza"
    // contro i bordi della griglia come una pallina da biliardo.
    // Le caselle pi√π vicine all'epicentro hanno una probabilit√† maggiore di essere
    // estratte come caselle rosse; quelle lontane una probabilit√† minore.

    function initDangerZone() {
        const row = 1 + Math.floor(Math.random() * (GRID_SIZE - 2));
        const col = 1 + Math.floor(Math.random() * (GRID_SIZE - 2));
        const signs = [-1, 1];
        const dr = signs[Math.floor(Math.random() * 2)];
        const dc = signs[Math.floor(Math.random() * 2)];
        gameState.dangerZone = { row, col, dir: { dr, dc } };
        // Nessun rendering: la zona √® nascosta
    }

    function moveDangerZone() {
        const dz = gameState.dangerZone;
        let newRow = dz.row + dz.dir.dr;
        let newCol = dz.col + dz.dir.dc;

        if (newRow < 0 || newRow >= GRID_SIZE) {
            dz.dir.dr *= -1;
            newRow = dz.row + dz.dir.dr;
        }
        if (newCol < 0 || newCol >= GRID_SIZE) {
            dz.dir.dc *= -1;
            newCol = dz.col + dz.dir.dc;
        }

        dz.row = newRow;
        dz.col = newCol;
        // Nessun rendering: la zona resta nascosta
    }

    // ‚îÄ‚îÄ‚îÄ Calcolo Punteggio Posizionale ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Calcola il bonus punti basato sulla distanza dal centro della griglia
    // Centro = pi√π rischioso = pi√π punti
    // Bordi = pi√π sicuro = meno punti
    function calculatePositionScore(row, col) {
        const center = Math.floor(GRID_SIZE / 2); // 3 per griglia 7x7
        const distance = Math.abs(row - center) + Math.abs(col - center); // Manhattan distance
        
        // Mappa distanza ‚Üí punteggio
        const scoreMap = {
            0: 150,  // Centro assoluto
            1: 110,  // Vicinissimo al centro
            2: 80,   // Vicino al centro
            3: 50,   // Zona media
            4: 30,   // Zona esterna
            5: 15,   // Quasi bordo
            6: 10    // Angoli
        };
        
        return scoreMap[distance] || 10; // Default 10 se fuori range
    }

    // Mostra animazione del punteggio posizionale sulla cella
    function showPositionScoreAnimation(cellElement, points) {
        const scoreEl = document.createElement('div');
        scoreEl.className = 'position-score';
        
        // Aggiungi classe speciale per punteggi alti (‚â•100)
        if (points >= 100) {
            scoreEl.classList.add('high-value');
        }
        
        scoreEl.textContent = `+${points}`;
        cellElement.appendChild(scoreEl);
        
        // Rimuovi elemento dopo l'animazione
        setTimeout(() => scoreEl.remove(), 1200);
        
        // Suono leggero per feedback (pitch pi√π alto per punteggi alti)
        if (points >= 100) {
            playPositionScoreHighSound(); // Centro griglia
        } else {
            playPositionScoreLowSound(); // Bordi griglia
        }
    }
    
    // Suono per punteggio posizionale alto (centro griglia)
    function playPositionScoreHighSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(880, now); // La5 - nota alta
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        o.start(now);
        o.stop(now + 0.15);
    }
    
    // Suono per punteggio posizionale basso (bordi griglia)
    function playPositionScoreLowSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(660, now); // Mi5 - nota media
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        o.start(now);
        o.stop(now + 0.12);
    }

    // Partiziona il pool in caselle DENTRO la zona (dist <= 2) e FUORI.
    // Poi pescano ~75% dalle caselle dentro e il resto dalle caselle fuori,
    // garantendo una concentrazione forte delle rosse nella zona senza
    // rivelare nulla visivamente.
    function extractDangerCells(pool, count) {
        const dz = gameState.dangerZone;

        const inside = [];
        const outside = [];
        pool.forEach(idx => {
            const row = Math.floor(idx / GRID_SIZE);
            const col = idx % GRID_SIZE;
            const dist = Math.max(Math.abs(row - dz.row), Math.abs(col - dz.col));
            if (dist <= 2) inside.push(idx);
            else outside.push(idx);
        });

        shuffle(inside);
        shuffle(outside);

        // Quante pescane dalla zona: 80% del totale richiesto, ma non pi√π di quelle disponibili dentro
        const fromInside = Math.min(inside.length, Math.round(count * 0.80));
        const fromOutside = Math.min(outside.length, count - fromInside);

        return inside.slice(0, fromInside).concat(outside.slice(0, fromOutside));
    }

    // ‚îÄ‚îÄ‚îÄ Selezione cella ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function selectCell(index) {
        if (!gameState.gameStarted) return; // blocca finch√© non clicchi "Nuova Partita"
        if (gameState.isPaused) return; // blocca durante notifiche bonus
        if (gameState.isProcessingReveal) return;
        if (gameState.eliminatedCells.has(index)) return;
        if (gameState.selectedCell === index) return;

        // Ferma il timer (il giocatore ha scelto)
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;

        // Deseleziona la cella precedente
        if (gameState.selectedCell !== null) {
            const prev = document.querySelector(`[data-index="${gameState.selectedCell}"]`);
            if (prev) prev.classList.remove('selected');
        }

        gameState.selectedCell = index;
        const cell = document.querySelector(`[data-index="${index}"]`);
        cell.classList.add('selected');

        // Controlla bonus nascosto
        if (gameState.bonusCells.has(index)) {
            const bonusTemplate = gameState.bonusCells.get(index);
            gameState.bonusCells.delete(index);

            if (bonusTemplate.id === 'malus') {
                // MALUS SFORTUNA: non va nei bonus raccolti, attiva subito il popup del mostro
                showMalusPopup();
            } else if (bonusTemplate.id === 'cardMalus') {
                // CARD MALUS: attiva popup carte maledette
                showCardMalusPopup();
            } else {
                // Bonus normale: crea una COPIA, non usare il riferimento!
                const bonus = {
                    id: bonusTemplate.id,
                    name: bonusTemplate.name,
                    icon: bonusTemplate.icon,
                    description: bonusTemplate.description,
                    used: false,
                    uniqueId: Date.now() + Math.random()
                };
                gameState.collectedBonuses.push(bonus);
                showBonusNotification(bonus);
                updateBonusDisplay();
            }
        }

        gameState.isProcessingReveal = true;
        
        // CHECK VITTORIA IMMEDIATA: se questa √® l'ultima casella disponibile, hai vinto!
        // Conta quante celle NON eliminate ci sono (esclusa quella appena selezionata che sar√† eliminata)
        let remainingCells = 0;
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== index) {
                remainingCells++;
            }
        }
        
        if (remainingCells === 0) {
            // VITTORIA! Questa era l'ultima casella
            updateMessage('üéâ ULTIMA CASELLA! HAI VINTO!', 'success');
            setTimeout(() => showVictory(), 1000);
            return; // Non chiamare revealCell()
        }
        
        updateMessage(t('msgCellSelected'), 'info');
        setTimeout(() => revealCell(), 500);
    }

    // ‚îÄ‚îÄ‚îÄ Preview bonus ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showBonusPreview() {
        return new Promise(resolve => {
            // Mostra messaggio
            updateMessage(t('msgMemorizeBonuses'), 'info');

            // Crea array delle celle bonus in ordine casuale
            const bonusCellsArray = Array.from(gameState.bonusCells.entries());
            shuffle(bonusCellsArray);

            // Accendi in sequenza
            const delayBetween = 300; // 0.3 secondi tra ogni bonus (ridotto da 500ms)
            const showDuration = 400; // quanto resta accesa ogni cella
            const totalDuration = (bonusCellsArray.length * delayBetween) + showDuration; // tempo totale dinamico

            bonusCellsArray.forEach(([cellIndex, bonus], i) => {
                setTimeout(() => {
                    const cell = document.querySelector(`[data-index="${cellIndex}"]`);
                    if (cell) {
                        cell.classList.add('bonus-preview');
                        cell.textContent = bonus.icon;
                        
                        // Spegni dopo showDuration
                        setTimeout(() => {
                            cell.classList.remove('bonus-preview');
                            cell.textContent = '';
                        }, showDuration);
                    }
                }, i * delayBetween);
            });

            // Dopo tutta la sequenza
            setTimeout(() => {
                updateMessage(t('msgSelectInstructions'), 'info');
                resolve();
            }, totalDuration);
        });
    }

    // ‚îÄ‚îÄ‚îÄ Avvio partita ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function startGame() {
        resetGame();
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('reset-btn').style.display = 'inline-block';
        document.getElementById('start-hand-hint').style.display = 'none'; // nascondi manina
        
        // Prima mostra il preview dei bonus
        await showBonusPreview();
        
        // Abilita il gioco
        gameState.gameStarted = true;
        
        // Poi avvia il timer
        setTimeout(() => {
            startTimer();
            updateLives(); // forza il re-render delle vite
        }, 50);
    }

    // ‚îÄ‚îÄ‚îÄ Timer (perimetro griglia) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function startTimer(retryCount = 0) {
        clearInterval(gameState.timerInterval);
        gameState.timeRemaining = TIMER_DURATION;

        const wrap  = document.getElementById('grid-wrap');
        const svg   = document.getElementById('timer-perimeter');
        const rect  = document.getElementById('timer-rect');

        // Misura la griglia dopo il layout
        const w = wrap.offsetWidth;
        const h = wrap.offsetHeight;

        // Se le dimensioni non sono ancora pronte, riprova (max 10 tentativi)
        if ((w < 50 || h < 50) && retryCount < 10) {
            setTimeout(() => startTimer(retryCount + 1), 20);
            return;
        }

        // Mostra il timer
        svg.classList.add('active');

        const strokeW = 6;
        const pad = strokeW / 2;          // centra lo stroke sul bordo
        const rx = 10;

        // Imposta dimensioni del rect nell'SVG (coordinate nel viewBox = pixel della griglia)
        svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
        rect.setAttribute('x', pad);
        rect.setAttribute('y', pad);
        rect.setAttribute('width',  w - strokeW);
        rect.setAttribute('height', h - strokeW);
        rect.setAttribute('rx', rx);
        rect.setAttribute('ry', rx);

        // Perimetro del rettangolo arrotondato: 2*(w+h) ‚àí 8*rx + 2*œÄ*rx
        const perim = 2 * (w - strokeW + h - strokeW) - 8 * rx + 2 * Math.PI * rx;

        rect.style.strokeDasharray  = perim;
        rect.style.strokeDashoffset = 0;
        svg.classList.remove('warning', 'danger');

        gameState.timerInterval = setInterval(() => {
            gameState.timeRemaining -= 0.1;
            if (gameState.timeRemaining < 0) gameState.timeRemaining = 0;

            // Aggiorna perimetro
            const pct    = gameState.timeRemaining / TIMER_DURATION;
            rect.style.strokeDashoffset = perim * (1 - pct);

            // Colore
            svg.classList.remove('warning', 'danger');
            if (gameState.timeRemaining <= 2)      svg.classList.add('danger');
            else if (gameState.timeRemaining <= 4) svg.classList.add('warning');

            // Ticchettio con frequenza crescente
            const secondsInt = Math.floor(gameState.timeRemaining);
            const fraction = gameState.timeRemaining - secondsInt;
            if (gameState.timeRemaining > 3) {
                // > 3s: tick ogni 1s
                if (fraction >= 0.9 && fraction < 1.0) playTickSound();
            } else if (gameState.timeRemaining > 1.5) {
                // 1.5-3s: tick ogni 0.5s
                if ((fraction >= 0.4 && fraction < 0.5) || (fraction >= 0.9 && fraction < 1.0)) playTickSound();
            } else if (gameState.timeRemaining > 0) {
                // < 1.5s: tick ogni 0.3s
                if ((fraction >= 0.2 && fraction < 0.3) || (fraction >= 0.5 && fraction < 0.6) || (fraction >= 0.8 && fraction < 0.9)) playTickSound();
            }

            // Tempo scaduto
            if (gameState.timeRemaining <= 0) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
                gameState.isProcessingReveal = true;
                updateMessage(t('msgTimeExpired'), 'danger');
                setTimeout(() => endGame(), 1500);
            }
        }, 100);
    }

    // ‚îÄ‚îÄ‚îÄ Rivelazione caselle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function revealCell() {
        gameState.isGameActive = false;

        if (gameState.selectedCell === null) {
            // Nessuna cella selezionata (non dovrebbe succedere qui, gestito nel timer)
            updateMessage(t('msgTimeUp'), 'danger');
            setTimeout(() => endGame(), 1500);
            return;
        }

        const userSelectedCell = gameState.selectedCell;

        // Pool delle caselle ancora disponibili
        const availableCells = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i)) availableCells.push(i);
        }

        // Questo check non dovrebbe mai scattare perch√© la vittoria viene rilevata in selectCell
        // Ma lo lasciamo come safety net
        if (availableCells.length === 0) {
            setTimeout(() => showVictory(), 1000);
            return;
        }

        // Calcola quante caselle rosse estrarre
        let cellsToReveal = calculateDifficulty(availableCells.length);
        
        // Applica effetto LUCKY: dimezza le celle rosse per questo turno
        if (gameState.luckyActive) {
            cellsToReveal = Math.ceil(cellsToReveal / 2);
            gameState.luckyActive = false; // consumato dopo un turno
        }

        // Applica effetto MALUS: raddoppia le celle rosse per questo turno
        if (gameState.malusActive) {
            cellsToReveal = Math.min(cellsToReveal * 2, availableCells.length - 1); // lascia almeno 1 cella libera
            gameState.malusActive = false; // consumato dopo un turno
        }

        // Se il malus √® stato trovato QUESTO turno, promuovilo per il prossimo
        if (gameState.malusFound) {
            gameState.malusFound = false;
            gameState.malusActive = true; // si attiva al PROSSIMO revealCell
        }
        
        cellsToReveal = Math.min(cellsToReveal, availableCells.length);

        // Pool per l'estrazione delle caselle rosse.
        // Escludi le caselle protette dalla visione ‚Äî inclusa quella dell'utente se l'ha scelta.
        // Se l'utente ha scelto una casella visione-safe, √® protetto: non pu√≤ essere colpito.
        const dangerPool = availableCells.filter(idx =>
            !gameState.safeCells.includes(idx)
        );

        // Se il dangerPool √® vuoto (tutte le caselle rimaste sono protette dalla visione)
        // pescana comunque dalle disponibili normalmente
        const effectivePool = dangerPool.length > 0 ? dangerPool : availableCells;

        // Estrai le caselle rosse: ~75% dalla zona di pericolo nascosta, resto casuale
        const randomCells = extractDangerCells(effectivePool, Math.min(cellsToReveal, effectivePool.length));

        // L'utente √® colpito se la sua cella √® stata estratta
        let userWasHit = randomCells.includes(userSelectedCell);

        // ‚îÄ‚îÄ Scudo: gestione corretta ‚îÄ‚îÄ
        let shieldUsed = false;
        if (userWasHit && gameState.activeShield) {
            userWasHit = false;
            shieldUsed = true;
            gameState.activeShield = false;
            updateShieldIndicator();
            updateBonusDisplay();
        }

        // Elimina la casella scelta dall'utente (sempre sicura)
        const selectedEl = document.querySelector(`[data-index="${userSelectedCell}"]`);
        selectedEl.classList.remove('selected');
        selectedEl.classList.add('eliminated');
        gameState.eliminatedCells.add(userSelectedCell);
        gameState.cellsEliminated++;
        gameState.currentStreak++;
        if (gameState.currentStreak > gameState.bestStreak) gameState.bestStreak = gameState.currentStreak;

        // Punti con sistema misto: esponenziale (1-10) + incrementale (11+)
        gameState.pointsStreak++;
        let points;
        
        if (gameState.pointsStreak <= CAP_STREAK) {
            // Fase 1: Esponenziale (streak 1-10)
            points = Math.round(BASE_POINTS * Math.pow(POINTS_MULTIPLIER, gameState.pointsStreak - 1));
        } else {
            // Fase 2: Cap + Bonus Incrementali (streak 11+)
            points = 384; // Cap value at streak 10
            for (let s = 11; s <= gameState.pointsStreak; s++) {
                const bonus = BASE_BONUS + ((s - 11) * BONUS_INCREMENT);
                points += bonus;
            }
        }
        
        if (gameState.doublePointsRemaining > 0) {
            points *= 2;
            gameState.doublePointsRemaining--;
        }
        
        // ‚ú® PUNTEGGIO POSIZIONALE: bonus basato sulla posizione nella griglia
        // Calcolato dalla cella selezionata (non influenzato da streak o moltiplicatori)
        const selectedRow = Math.floor(userSelectedCell / GRID_SIZE);
        const selectedCol = userSelectedCell % GRID_SIZE;
        const positionBonus = calculatePositionScore(selectedRow, selectedCol);
        
        // Aggiungi punteggio base (con streak/multiplier) + bonus posizionale (senza multiplier)
        gameState.score += points;
        gameState.score += positionBonus; // Aggiunto separatamente, senza moltiplicatori
        
        // Mostra animazione del punteggio posizionale
        showPositionScoreAnimation(selectedEl, positionBonus);
        
        if (gameState.currentStreak >= 3) showCombo();
        createParticles(selectedEl);
        updateStats();
        updateMessage(tpl('msgPointsWait', {points}), 'info');

        // Dopo 500ms ‚Üí mostra le caselle rosse
        setTimeout(() => {
            randomCells.forEach(idx => {
                const el = document.querySelector(`[data-index="${idx}"]`);
                if (!gameState.eliminatedCells.has(idx)) el.classList.add('revealed');
            });

            // Dopo altri 1000ms ‚Üí messaggio risultato
            setTimeout(() => {
                if (shieldUsed) {
                    showBonusNotification({ name: t('bonusShieldUsed'), icon: 'üõ°Ô∏è', description: t('bonusShieldUsedDesc') });
                    updateMessage(t('msgShieldSaved'), 'success');

                } else if (userWasHit && gameState.lifelineActive) {
                    // ‚îÄ‚îÄ Lifeline: almeno una delle 5 caselle deve sopravvivere ‚îÄ‚îÄ
                    const survivors = gameState.lifelineCells.filter(idx => !randomCells.includes(idx));

                    if (survivors.length > 0) {
                        // Almeno una casella sopravvisse ‚Üí salvi!
                        // Evidenzia la prima sopravvissuta in verde brillante
                        const survivorEl = document.querySelector(`[data-index="${survivors[0]}"]`);
                        if (survivorEl) {
                            survivorEl.classList.remove('lifeline-active');
                            survivorEl.classList.add('lifeline-survived');
                        }
                        showBonusNotification({ name: t('bonusLifelineSaved'), icon: 'üÜò', description: t('bonusLifelineSavedDesc') });
                        updateMessage(t('msgLifelineSurvived'), 'success');
                    } else {
                        // Tutte e 5 le caselle lifeline sono rosse ‚Üí perdi una vita
                        selectedEl.classList.add('hit');
                        updateMessage(t('msgLifelineFailed'), 'danger');
                        loseLife();
                        return;
                    }

                } else if (userWasHit) {
                    // Colpito senza scudo n√© lifeline ‚Üí perdi una vita
                    selectedEl.classList.add('hit');
                    updateMessage(tpl('msgOhNo', {count: cellsToReveal}), 'danger');
                    loseLife();
                    return;

                } else {
                    updateMessage(tpl('msgSafe', {count: cellsToReveal}), 'success');
                }

                // Cleanup dopo 1500ms
                setTimeout(() => {
                    randomCells.forEach(idx => {
                        const el = document.querySelector(`[data-index="${idx}"]`);
                        el.classList.remove('revealed');
                    });
                    clearVision();
                    clearLifeline();
                    gameState.selectedCell = null;
                    gameState.isProcessingReveal = false;

                    // Muovi la zona di pericolo per il prossimo round
                    moveDangerZone();

                    updateMessage(t('msgSelectNext'), 'info');

                    // Riavvia il timer per il prossimo round
                    startTimer();
                }, 1500);
            }, 1000);
        }, 500);
    }

    // ‚îÄ‚îÄ‚îÄ Difficolt√† dinamica ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function calculateDifficulty(remainingCells) {
        const total = GRID_SIZE * GRID_SIZE; // 49
        const pct = remainingCells / total;

        // Parte da 15, scende lentamente ‚Äî la pressione resta alta fino alla fine
        if (pct > 0.9)  return 15;  // ~45 rimaste ‚Üí 15 rosse (~33%)
        if (pct > 0.8)  return 14;  // ~40 rimaste ‚Üí 14 rosse (~35%)
        if (pct > 0.7)  return 12;  // ~35 rimaste ‚Üí 12 rosse (~34%)
        if (pct > 0.6)  return 10;  // ~30 rimaste ‚Üí 10 rosse (~33%)
        if (pct > 0.5)  return 8;   // ~25 rimaste ‚Üí  8 rosse (~32%)
        if (pct > 0.4)  return 7;   // ~20 rimaste ‚Üí  7 rosse (~35%)
        if (pct > 0.3)  return 5;   // ~15 rimaste ‚Üí  5 rosse (~33%)
        if (pct > 0.2)  return 4;   // ~10 rimaste ‚Üí  4 rosse (~40%)
        if (pct > 0.1)  return 2;   // ~5  rimaste ‚Üí  2 rosse (~40%)
        return 1;
    }

    // ‚îÄ‚îÄ‚îÄ Combo display ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showCombo() {
        const combo = document.getElementById('combo');
        let text = '';
        if (gameState.currentStreak >= 10)      text = tpl('streakLegendary', {count: gameState.currentStreak});
        else if (gameState.currentStreak >= 7)  text = tpl('streakIncredible', {count: gameState.currentStreak});
        else if (gameState.currentStreak >= 5)  text = tpl('streakFantastic', {count: gameState.currentStreak});
        else if (gameState.currentStreak >= 3)  text = tpl('streakCombo', {count: gameState.currentStreak});
        combo.textContent = text;
        setTimeout(() => { combo.textContent = ''; }, 2000);
    }

    // ‚îÄ‚îÄ‚îÄ Bonus: notifica, display, attivazione ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showBonusNotification(bonus, onComplete) {
        // Pausa il gioco: blocca le interazioni E ferma il timer
        gameState.isPaused = true;
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
        
        const el = document.getElementById('bonus-notification');
        el.innerHTML = `${bonus.icon} ${t(bonus.name)}!<br><small style="font-size:0.5em;">${t(bonus.description)}</small>`;
        el.classList.add('show');
        
        setTimeout(() => {
            el.classList.remove('show');
            gameState.isPaused = false;
            // Se c'√® un callback (es. attivazione differita di visione/magnete), eseguilo
            if (onComplete) onComplete();
            // Riavvia il timer se il gioco √® iniziato e non siamo nel mezzo di una rivelazione
            if (gameState.gameStarted && !gameState.isProcessingReveal) {
                startTimer();
            }
        }, 2500);
    }

    function updateBonusDisplay() {
        const container = document.getElementById('bonuses');
        container.innerHTML = '';

        // Se non c'√® ancora lo snapshot (prima di initGrid) non fare nulla
        if (!gameState.allBonusesInGame) return;

        // Costruisci una copia della lista dei bonus raccolti ancora disponibili per il matching
        // Uso un array di flag per evitare di matchare lo stesso bonus raccolto due volte
        const collectedUsed = gameState.collectedBonuses.map(() => false);

        gameState.allBonusesInGame.forEach((slotBonus) => {
            // Cerca un bonus raccolto corrispondente che non sia gi√† stato matchato
            let matchIdx = -1;
            for (let i = 0; i < gameState.collectedBonuses.length; i++) {
                if (!collectedUsed[i] && gameState.collectedBonuses[i].id === slotBonus.id) {
                    matchIdx = i;
                    break;
                }
            }

            const card = document.createElement('div');

            if (matchIdx !== -1) {
                // ‚îÄ‚îÄ Bonus gi√† raccolto ‚îÄ‚îÄ
                collectedUsed[matchIdx] = true;
                const collected = gameState.collectedBonuses[matchIdx];
                
                // Gestisci bonus rimosso dal card malus
                if (collected.removed) {
                    card.className = 'bonus-card removed';
                    card.innerHTML = `<div class="bonus-icon">${collected.icon}</div><div class="bonus-name">${t(collected.name)}</div>`;
                    card.style.cursor = 'not-allowed';
                    card.title = 'Rimosso da Card Malus';
                } else if (collected.used) {
                    card.className = 'bonus-card used';
                    card.innerHTML = `<div class="bonus-icon">${collected.icon}</div><div class="bonus-name">${t(collected.name)}</div>`;
                    card.style.cursor = 'not-allowed';
                    card.title = 'Gi√† usato';
                } else {
                    card.className = 'bonus-card';
                    card.innerHTML = `<div class="bonus-icon">${collected.icon}</div><div class="bonus-name">${t(collected.name)}</div>`;
                    card.addEventListener('click', () => activateBonus(collected.uniqueId));
                }
            } else {
                // ‚îÄ‚îÄ Ancora sulla griglia (non trovato) ‚îÄ‚îÄ
                card.className = 'bonus-card disabled';
                card.innerHTML = `<div class="bonus-icon">${slotBonus.icon}</div><div class="bonus-name">${t(slotBonus.name)}</div>`;
                card.title = 'Non ancora trovato';
            }

            container.appendChild(card);
        });

        // Controlla se la barra √® scrollabile e aggiorna stile + hint
        const bonusContainer = document.getElementById('bonuses');
        const hint = document.getElementById('bonus-scroll-hint');
        
        // Aspetta che il DOM si aggiorni per misure corrette
        setTimeout(() => {
            const isScrollable = bonusContainer.scrollWidth > bonusContainer.clientWidth;
            
            if (isScrollable) {
                // Aggiungi classe per allineamento sinistra + gradient
                bonusContainer.classList.add('scrollable');
                
                // Mostra hint solo la PRIMA volta
                if (!gameState.bonusHintShown && gameState.collectedBonuses.length === 1) {
                    gameState.bonusHintShown = true; // marca come mostrato
                    
                    hint.style.display = 'block';
                    hint.style.opacity = '0';
                    setTimeout(() => { hint.style.opacity = '1'; }, 10);
                    hint.style.transition = 'opacity 0.3s ease';
                    
                    // Nascondi dopo 3 secondi con fade-out
                    setTimeout(() => {
                        hint.style.opacity = '0';
                        setTimeout(() => { hint.style.display = 'none'; }, 300);
                    }, 3000);
                }
            } else {
                // Rimuovi classe per centrare
                bonusContainer.classList.remove('scrollable');
                hint.style.display = 'none';
            }
        }, 50);
    }

    function activateBonus(uniqueId) {
        // Trova il bonus tramite uniqueId
        const bonus = gameState.collectedBonuses.find(b => b.uniqueId === uniqueId);
        if (!bonus) return;
        if (gameState.isPaused) return; // blocca durante notifiche
        if (bonus.used) return; // gi√† usato
        if (bonus.removed) return; // rimosso dal Card Malus
        
        // Marca come usato SOLO questo specifico bonus tramite uniqueId
        bonus.used = true;

        switch (bonus.id) {
            case 'shield':
                gameState.activeShield = true;
                updateShieldIndicator();
                playShieldSound();
                showBonusNotification({ name: t('bonusShieldActive'), icon: 'üõ°Ô∏è', description: t('bonusShieldActiveDesc') });
                break;
            case 'eliminate3':
                eliminateRandomCells(3);
                showBonusNotification({ name: t('notifTriple'), icon: 'üí£', description: t('notifTripleDesc') });
                break;
            case 'sniper':
                activateSniper();
                showBonusNotification({ name: t('notifSniper'), icon: 'üéØ', description: t('notifSniperDesc') });
                break;
            case 'vision':
                // Mostra prima il messaggio, poi attiva la visione dopo che sparisce
                showBonusNotification({ name: t('notifVision'), icon: 'üëÅÔ∏è', description: t('notifVisionDesc') }, () => {
                    activateVision();
                });
                break;
            case 'magnet':
                // Mostra prima il messaggio, poi attiva il magnete dopo che sparisce
                showBonusNotification({ name: t('notifMagnet'), icon: 'üß≤', description: t('notifMagnetDesc') }, () => {
                    activateMagnet();
                });
                break;
            case 'lucky':
                gameState.luckyActive = true;
                showBonusNotification({ name: t('notifLucky'), icon: 'üé≤', description: t('notifLuckyDesc') });
                break;
            case 'doublePoints':
                gameState.doublePointsRemaining = 3;
                showBonusNotification({ name: t('notifX2'), icon: 'üí∞', description: t('notifX2Desc') });
                break;
            case 'points750':
                gameState.score += 750;
                updateStats();
                showBonusNotification({ name: t('notif750'), icon: 'üíµ', description: t('notif750Desc') });
                break;
            case 'points1500':
                gameState.score += 1500;
                updateStats();
                showBonusNotification({ name: t('notif1500'), icon: 'üí∏', description: t('notif1500Desc') });
                break;
            case 'points3000':
                gameState.score += 3000;
                updateStats();
                showBonusNotification({ name: t('notif3000'), icon: 'üíé', description: t('notif3000Desc') });
                break;
            case 'extraLife':
                if (gameState.lives < 3) {
                    gameState.lives++;
                    updateLives();
                    showBonusNotification({ name: t('bonusExtraLife'), icon: '‚ù§Ô∏è', description: t('notifLifeDesc') });
                } else {
                    showBonusNotification({ name: t('bonusLifeFull'), icon: '‚ù§Ô∏è', description: t('bonusLifeFullDesc') });
                }
                break;
        }
        updateBonusDisplay();
    }

    function updateShieldIndicator() {
        document.getElementById('shield-badge').classList.toggle('show', gameState.activeShield);
    }

    // ‚îÄ‚îÄ‚îÄ Vite ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function updateLives() {
        const container = document.getElementById('lives');
        container.innerHTML = '';
        for (let i = 0; i < 3; i++) {
            const heart = document.createElement('span');
            heart.className = 'life-heart' + (i >= gameState.lives ? ' lost' : '');
            heart.textContent = i < gameState.lives ? '‚ù§Ô∏è' : 'üñ§';
            container.appendChild(heart);
        }
    }

    function loseLife() {
        gameState.lives--;
        gameState.currentStreak = 0;
        gameState.pointsStreak  = 0;
        updateStats();
        updateLives();
        playLifeLostSound(); // suono perdita vita

        if (gameState.lives <= 0) {
            // Ultima vita persa ‚Üí game over
            const monsterIdx = Math.floor(Math.random() * MONSTERS.length);
            playMonsterSound(monsterIdx);
            setTimeout(() => {
                showMonster(monsterIdx);
                setTimeout(() => endGame(), 2000);
            }, 1000);
        } else {
            // Ancora vite rimaste ‚Üí riprendi dopo una pausa
            updateMessage(tpl('msgLifeLost', {lives: gameState.lives}), 'danger');
            setTimeout(() => {
                document.querySelectorAll('.revealed').forEach(el => el.classList.remove('revealed'));
                clearVision();
                clearLifeline();
                gameState.selectedCell = null;
                gameState.isProcessingReveal = false;
                moveDangerZone();
                updateMessage(t('msgSelectNext'), 'info');
                startTimer();
            }, 2000);
        }
    }

    function eliminateRandomCells(count) {
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) available.push(i);
        }
        shuffle(available);
        const eliminated = available.slice(0, Math.min(count, available.length));
        
        eliminated.forEach(idx => {
            gameState.eliminatedCells.add(idx);
            
            // Se la cella contiene un bonus, brucialo e barralo
            if (gameState.bonusCells.has(idx)) {
                burnBonus(idx);
            }
            
            const el = document.querySelector(`[data-index="${idx}"]`);
            el.classList.add('eliminated');
            createParticles(el);
        });
        
        // CHECK VITTORIA: se dopo aver eliminato le caselle non ne rimangono pi√π
        checkVictoryAfterElimination();
    }
    
    // Helper: brucia un bonus dalla griglia e aggiungilo come "removed" alla barra
    function burnBonus(cellIdx) {
        const bonusTemplate = gameState.bonusCells.get(cellIdx);
        if (!bonusTemplate) return;
        
        // Rimuovi dalla mappa
        gameState.bonusCells.delete(cellIdx);
        
        // Aggiungilo ai bonus raccolti ma marcato come "removed"
        const burnedBonus = {
            id: bonusTemplate.id,
            name: bonusTemplate.name,
            icon: bonusTemplate.icon,
            description: 'Bruciato da Sniper/Triplo',
            used: false,
            removed: true, // flag speciale
            uniqueId: Date.now() + Math.random()
        };
        
        gameState.collectedBonuses.push(burnedBonus);
        
        // Aggiorna display per mostrare il bonus barrato
        updateBonusDisplay();
    }
    
    function checkVictoryAfterElimination() {
        let remainingCells = 0;
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) {
                remainingCells++;
            }
        }
        
        if (remainingCells === 0) {
            // VITTORIA! Tutte le caselle eliminate (incluse quelle con bonus)
            clearInterval(gameState.timerInterval);
            gameState.timerInterval = null;
            updateMessage(t('msgLastCell'), 'success');
            setTimeout(() => showVictory(), 1500);
        }
    }

    // ‚îÄ‚îÄ‚îÄ Visione: rivela caselle sicure e le MEMORIZZA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateVision() {
        clearVision(); // pulisci eventuale visione precedente

        gameState.visionActive = true;
        gameState.safeCells = [];

        // Trova tutte le caselle non ancora eliminate e non quella selezionata
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) available.push(i);
        }

        // Mostra esattamente 3 caselle sicure (indipendente dalle rimaste)
        const count = Math.min(3, available.length);
        shuffle(available);
        gameState.safeCells = available.slice(0, count);

        gameState.safeCells.forEach(idx => {
            const el = document.querySelector(`[data-index="${idx}"]`);
            el.classList.add('vision-safe');
        });
    }

    function clearVision() {
        document.querySelectorAll('.vision-safe').forEach(el => el.classList.remove('vision-safe'));
        gameState.visionActive = false;
        gameState.safeCells = [];
    }

    // ‚îÄ‚îÄ‚îÄ Lifeline ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateLifeline() {
        clearLifeline();
        gameState.lifelineActive = true;

        // Pescana 5 caselle random tra quelle non ancora eliminate (escludi quella selezionata)
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) available.push(i);
        }
        shuffle(available);
        gameState.lifelineCells = available.slice(0, Math.min(5, available.length));

        // Accendi visivamente le 5 caselle in oro
        gameState.lifelineCells.forEach(idx => {
            const el = document.querySelector(`[data-index="${idx}"]`);
            if (el) el.classList.add('lifeline-active');
        });
    }

    function clearLifeline() {
        document.querySelectorAll('.lifeline-active, .lifeline-survived').forEach(el => {
            el.classList.remove('lifeline-active', 'lifeline-survived');
        });
        gameState.lifelineActive = false;
        gameState.lifelineCells = [];
    }

    // ‚îÄ‚îÄ‚îÄ Sniper: elimina 1 casella rossa garantita ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateSniper() {
        // Trova tutte le celle disponibili (non eliminate, non selezionate)
        const available = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            if (!gameState.eliminatedCells.has(i) && i !== gameState.selectedCell) {
                available.push(i);
            }
        }
        
        if (available.length === 0) return;
        
        // Scegli una casella casuale e marcala come "safe" cos√¨ non verr√† mai scelta come rossa
        const targetIdx = available[Math.floor(Math.random() * available.length)];
        gameState.eliminatedCells.add(targetIdx);
        
        // Se la cella contiene un bonus, brucialo e barralo
        if (gameState.bonusCells.has(targetIdx)) {
            burnBonus(targetIdx);
        }
        
        const el = document.querySelector(`[data-index="${targetIdx}"]`);
        el.classList.add('eliminated');
        createParticles(el);
        
        // Effetto visivo speciale per sniper (flash rosso poi verde)
        el.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        setTimeout(() => {
            el.style.background = '';
        }, 300);
        
        // CHECK VITTORIA: se sniper ha eliminato l'ultima casella
        checkVictoryAfterElimination();
    }

    // ‚îÄ‚îÄ‚îÄ Magnet: rivela tutti i bonus rimasti per 3 secondi ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function activateMagnet() {
        // Trova tutti i bonus non ancora raccolti
        const bonusPositions = [];
        gameState.bonusCells.forEach((bonus, cellIdx) => {
            bonusPositions.push({ idx: cellIdx, bonus: bonus });
        });
        
        if (bonusPositions.length === 0) {
            // Nessun bonus rimasto
            return;
        }
        
        // Mostra tutti i bonus con l'icona per 3 secondi
        bonusPositions.forEach(({ idx, bonus }) => {
            const cell = document.querySelector(`[data-index="${idx}"]`);
            if (cell && !gameState.eliminatedCells.has(idx)) {
                cell.classList.add('magnet-reveal');
                cell.textContent = bonus.icon;
            }
        });
        
        // Nascondi dopo 3 secondi
        setTimeout(() => {
            bonusPositions.forEach(({ idx }) => {
                const cell = document.querySelector(`[data-index="${idx}"]`);
                if (cell) {
                    cell.classList.remove('magnet-reveal');
                    cell.textContent = '';
                }
            });
        }, 3000);
    }

    // ‚îÄ‚îÄ‚îÄ Particelle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function createParticles(cell) {
        const rect = cell.getBoundingClientRect();
        const container = document.querySelector('.game-container');
        const cRect = container.getBoundingClientRect();
        for (let i = 0; i < 8; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.left = (rect.left - cRect.left + rect.width / 2) + 'px';
            p.style.top  = (rect.top  - cRect.top  + rect.height / 2) + 'px';
            p.style.transform = `translate(${Math.random() * 60 - 30}px, ${Math.random() * 60 - 30}px)`;
            container.appendChild(p);
            setTimeout(() => p.remove(), 1000);
        }
    }

    // ‚îÄ‚îÄ‚îÄ Mostro ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showMonster(monsterIdx) {
        const monster = MONSTERS[monsterIdx];
        document.getElementById('monster-emoji').textContent = monster.emoji;
        document.getElementById('monster-text').textContent  = t(monster.text); // ‚úÖ FIX: usa traduzione
        const popup = document.getElementById('monster-popup');
        popup.classList.add('show');
        setTimeout(() => popup.classList.remove('show'), 2000);
    }

    // ‚îÄ‚îÄ‚îÄ Malus popup: mostro cattivo che ride ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showMalusPopup() {
        // Calcola celle libere rimaste (escludi quelle gi√† eliminate)
        const availableCells = (GRID_SIZE * GRID_SIZE) - gameState.eliminatedCells.size;
        
        // Calcola quante celle rosse ci saranno al prossimo turno (raddoppiate dal malus)
        const normalReds = calculateDifficulty(availableCells);
        const doubledReds = Math.min(normalReds * 2, availableCells - 1); // raddoppiate, ma lascia almeno 1 libera
        
        // Celle realmente sicure = celle disponibili - rosse raddoppiate
        const safeCells = availableCells - doubledReds;

        // Pausa tutto
        gameState.isPaused = true;
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;

        // Attiva l'effetto malus per il prossimo turno (non questo!)
        gameState.malusFound = true;

        // Risata
        playEvilLaughSound();

        // Messaggio dalla bocca del mostro
        document.getElementById('malus-text').innerHTML = tpl('malusPopupText', {count: safeCells});

        const popup = document.getElementById('malus-popup');
        popup.classList.add('show');

        // Dopo 2.8s chiudi e riavvia
        setTimeout(() => {
            popup.classList.remove('show');
            gameState.isPaused = false;
            if (gameState.gameStarted && !gameState.isProcessingReveal) {
                startTimer();
            }
        }, 2800);
    }

    // ‚îÄ‚îÄ‚îÄ Card Malus Popup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let cardMalusValues = [];
    
    function showCardMalusPopup() {
        // Pausa tutto
        gameState.isPaused = true;
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;

        // Genera valori casuali delle carte (1, 2, 3 in ordine casuale)
        cardMalusValues = [1, 2, 3];
        shuffle(cardMalusValues);

        // Mostra popup
        const popup = document.getElementById('card-malus-popup');
        popup.classList.add('show');
        
        // Suono inquietante
        playCardMalusSound();
    }

    function selectCard(cardIndex) {
        const lostBonusCount = cardMalusValues[cardIndex];
        
        // Animazione flip
        const cards = document.querySelectorAll('.card');
        cards[cardIndex].classList.add('flipped');
        
        // Mostra il valore
        setTimeout(() => {
            cards[cardIndex].querySelector('.card-back').textContent = lostBonusCount;
            cards[cardIndex].style.background = lostBonusCount === 1 ? 
                'linear-gradient(135deg, #10b981 0%, #059669 100%)' : 
                lostBonusCount === 2 ?
                'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' :
                'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        }, 300);

        // Dopo 1.5s rimuovi i bonus e chiudi
        setTimeout(() => {
            removeBonuses(lostBonusCount);
            const popup = document.getElementById('card-malus-popup');
            popup.classList.remove('show');
            
            // Reset cards per prossima volta
            cards.forEach(card => {
                card.classList.remove('flipped');
                card.querySelector('.card-back').textContent = '?';
                card.style.background = 'linear-gradient(135deg, #4f46e5 0%, #6366f1 100%)';
            });
            
            gameState.isPaused = false;
            if (gameState.gameStarted && !gameState.isProcessingReveal) {
                startTimer();
            }
        }, 2000);
    }

    function removeBonuses(count) {
        let actuallyRemoved = 0;
        const removedBonusTypes = []; // traccia quali bonus sono stati rimossi dalla griglia
        
        // 1. Rimuovi bonus dalla GRIGLIA (se ancora presenti e non raccolti)
        const bonusesToRemove = [];
        gameState.bonusCells.forEach((bonus, cellIdx) => {
            if (actuallyRemoved < count && bonus.id !== 'malus' && bonus.id !== 'cardMalus') {
                bonusesToRemove.push({ cellIdx, bonus });
                actuallyRemoved++;
            }
        });
        
        bonusesToRemove.forEach(({ cellIdx, bonus }) => {
            gameState.bonusCells.delete(cellIdx);
            removedBonusTypes.push({ id: bonus.id, name: bonus.name, icon: bonus.icon });
        });
        
        // 2. Crea "placeholder" nei collectedBonuses per i bonus rimossi dalla griglia
        // cos√¨ appariranno barrati nella barra anche se non erano stati raccolti
        removedBonusTypes.forEach(bonusType => {
            gameState.collectedBonuses.push({
                id: bonusType.id,
                name: bonusType.name,
                icon: bonusType.icon,
                uniqueId: Date.now() + Math.random(),
                used: false,
                removed: true // subito marcato come rimosso
            });
        });
        
        // 3. Marca anche bonus raccolti come "removed" se non bastano quelli dalla griglia
        let stillNeedToRemove = count - bonusesToRemove.length;
        if (stillNeedToRemove > 0) {
            // Prima marca i non-usati
            for (let i = gameState.collectedBonuses.length - 1; i >= 0 && stillNeedToRemove > 0; i--) {
                const bonus = gameState.collectedBonuses[i];
                if (!bonus.removed && !bonus.used) {
                    bonus.removed = true;
                    stillNeedToRemove--;
                    actuallyRemoved++;
                }
            }
            
            // Poi se serve, marca anche quelli usati
            if (stillNeedToRemove > 0) {
                for (let i = gameState.collectedBonuses.length - 1; i >= 0 && stillNeedToRemove > 0; i--) {
                    const bonus = gameState.collectedBonuses[i];
                    if (!bonus.removed && bonus.used) {
                        bonus.removed = true;
                        stillNeedToRemove--;
                        actuallyRemoved++;
                    }
                }
            }
        }
        
        // Aggiorna display
        updateBonusDisplay();
        
        // Messaggio
        if (actuallyRemoved > 0) {
            updateMessage(tpl('msgBonusesLost', {count: actuallyRemoved}), 'danger');
        } else {
            updateMessage(t('msgNoBonusToLose'), 'info');
        }
    }

    function playCardMalusSound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        
        // Suono discendente inquietante
        [400, 350, 300, 250].forEach((freq, i) => {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.connect(g);
            g.connect(ctx.destination);
            o.type = 'triangle';
            o.frequency.setValueAtTime(freq, now + i * 0.1);
            g.gain.setValueAtTime(0.2, now + i * 0.1);
            g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.2);
            o.start(now + i * 0.1);
            o.stop(now + i * 0.1 + 0.2);
        });
    }

    // ‚îÄ‚îÄ‚îÄ Vittoria ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function showVictory() {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
        gameState.isGameActive = false;
        gameState.victoryAchieved = true; // Flag vittoria per classifica

        // Popola statistiche
        document.getElementById('victory-score').textContent = gameState.score.toLocaleString();
        document.getElementById('victory-streak').textContent = gameState.bestStreak;

        // Crea confetti
        createConfetti();

        // Mostra overlay
        document.getElementById('victory-overlay').classList.add('show');

        // Suono vittoria
        playVictorySound();
    }

    function closeVictory() {
        document.getElementById('victory-overlay').classList.remove('show');
        // Apri direttamente il game over per salvare punteggio
        endGame();
    }

    function createConfetti() {
        const container = document.getElementById('victory-confetti');
        container.innerHTML = '';
        const colors = ['#fbbf24', '#f59e0b', '#ef4444', '#10b981', '#3b82f6', '#8b5cf6'];
        
        for (let i = 0; i < 50; i++) {
            const confetto = document.createElement('div');
            confetto.style.position = 'absolute';
            confetto.style.width = '10px';
            confetto.style.height = '10px';
            confetto.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetto.style.left = Math.random() * 100 + '%';
            confetto.style.top = '-20px';
            confetto.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
            confetto.style.opacity = '0.8';
            confetto.style.animation = `confettiFall ${2 + Math.random() * 3}s linear ${Math.random() * 2}s infinite`;
            container.appendChild(confetto);
        }
    }

    // Aggiungi animazione confetti al CSS inline
    if (!document.getElementById('confetti-style')) {
        const style = document.createElement('style');
        style.id = 'confetti-style';
        style.textContent = `
            @keyframes confettiFall {
                to {
                    transform: translateY(600px) rotate(${Math.random() * 720 - 360}deg);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }

    function playVictorySound() {
        if (!soundEnabled) return;
        const ctx = getAudioCtx();
        const now = ctx.currentTime;
        
        // Sequenza ascendente di note trionfali
        const notes = [261.63, 329.63, 392.00, 523.25]; // C, E, G, C alto
        notes.forEach((freq, i) => {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.connect(g);
            g.connect(ctx.destination);
            o.type = 'sine';
            o.frequency.setValueAtTime(freq, now + i * 0.15);
            g.gain.setValueAtTime(0.3, now + i * 0.15);
            g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.3);
            o.start(now + i * 0.15);
            o.stop(now + i * 0.15 + 0.3);
        });
    }

    // ‚îÄ‚îÄ‚îÄ Stats ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function updateStats() {
        document.getElementById('score').textContent            = gameState.score;
        document.getElementById('cells-eliminated').textContent = gameState.cellsEliminated;
        document.getElementById('streak').textContent           = gameState.currentStreak;
    }

    function updateMessage(text, type) {
        const el = document.getElementById('message');
        el.textContent = text;
        el.className = 'message ' + type;
    }

    // ‚îÄ‚îÄ‚îÄ Fine partita ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function endGame() {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
        gameState.isGameActive = false;

        document.getElementById('final-score').textContent  = gameState.score;
        document.getElementById('final-cells').textContent  = gameState.cellsEliminated;
        document.getElementById('final-streak').textContent = gameState.bestStreak;

        // Controlla se il punteggio entra nei primi 10 (verifica ONLINE se disponibile)
        let leaderboard = [];
        
        if (useOnlineLeaderboard && database) {
            try {
                const snapshot = await database.ref('leaderboard').orderByChild('score').limitToLast(10).once('value');
                const data = snapshot.val();
                if (data) {
                    leaderboard = Object.values(data);
                    leaderboard.sort((a, b) => b.score - a.score);
                }
            } catch (error) {
                console.error('Error checking online leaderboard:', error);
                // Fallback a locale
                leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
            }
        } else {
            leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
        }
        
        const qualifies = leaderboard.length < 10 || gameState.score > (leaderboard[leaderboard.length - 1]?.score || 0);

        document.getElementById('save-section').style.display    = qualifies ? 'block' : 'none';
        document.getElementById('no-save-section').style.display = qualifies ? 'none'  : 'block';

        if (qualifies) {
            // Reset input e emoji picker
            document.getElementById('player-name').value = '';
            document.getElementById('save-btn').disabled = true;
            selectedProfileEmoji = PROFILE_EMOJIS[0];
            renderEmojiPicker();
        }

        document.getElementById('game-over').classList.add('show');
    }

    // ‚îÄ‚îÄ‚îÄ Emoji picker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function renderEmojiPicker() {
        const container = document.getElementById('emoji-picker');
        container.innerHTML = '';
        PROFILE_EMOJIS.forEach((emoji, i) => {
            const div = document.createElement('div');
            div.className = 'emoji-option' + (emoji === selectedProfileEmoji ? ' selected-emoji' : '');
            div.textContent = emoji;
            div.addEventListener('click', () => {
                selectedProfileEmoji = emoji;
                renderEmojiPicker();
            });
            container.appendChild(div);
        });
    }

    function onNameInput() {
        const name = document.getElementById('player-name').value.trim();
        document.getElementById('save-btn').disabled = name.length === 0;
    }

    // ‚îÄ‚îÄ‚îÄ Classifica ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function saveToLeaderboard() {
        const playerName = document.getElementById('player-name').value.trim();
        if (!playerName) return;

        const entry = {
            name: playerName,
            emoji: selectedProfileEmoji,
            score: gameState.score,
            cells: gameState.cellsEliminated,
            streak: gameState.bestStreak,
            date: new Date().toLocaleDateString('it-IT'),
            timestamp: Date.now(),
            victory: gameState.victoryAchieved || false // flag vittoria (49/49)
        };

        // Salva locale (fallback se Firebase non funziona)
        let localLeaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
        localLeaderboard.push(entry);
        localLeaderboard.sort((a, b) => b.score - a.score);
        localLeaderboard = localLeaderboard.slice(0, 10);
        localStorage.setItem('gridSurvivorLeaderboard', JSON.stringify(localLeaderboard));

        // Salva online se Firebase √® configurato
        if (useOnlineLeaderboard && database) {
            try {
                await database.ref('leaderboard').push(entry);
                console.log('‚úÖ Score saved to online leaderboard');
            } catch (error) {
                console.error('‚ùå Failed to save online:', error);
                alert('Punteggio salvato localmente. La classifica online non √® disponibile.');
            }
        }

        document.getElementById('game-over').classList.remove('show');
        showLeaderboard(gameState.score); // passa il punteggio dell'utente per highlight
    }

    async function showLeaderboard(userScore = null) {
        const container = document.getElementById('leaderboard-list');
        const statusEl = document.getElementById('firebase-status');
        
        container.innerHTML = `<p style="padding:20px;color:#666;">‚è≥ ${t('lbLoading')}...</p>`;
        document.getElementById('leaderboard-overlay').classList.add('show');

        // Mostra stato connessione
        if (useOnlineLeaderboard) {
            statusEl.innerHTML = `üåê ${t('lbOnline')}`;
            statusEl.style.color = '#10b981';
        } else {
            statusEl.innerHTML = t('lbLocal');
            statusEl.style.color = '#f59e0b';
        }

        let leaderboard = [];

        // Carica da Firebase se disponibile
        if (useOnlineLeaderboard && database) {
            try {
                const snapshot = await database.ref('leaderboard').orderByChild('score').limitToLast(50).once('value');
                const data = snapshot.val();
                
                if (data) {
                    leaderboard = Object.values(data);
                    leaderboard.sort((a, b) => b.score - a.score);
                    leaderboard = leaderboard.slice(0, 10);
                    console.log('‚úÖ Loaded online leaderboard:', leaderboard.length, 'entries');
                }
            } catch (error) {
                console.error('‚ùå Failed to load online leaderboard:', error);
                statusEl.innerHTML = `‚ö†Ô∏è ${t('lbError')}`;
                statusEl.style.color = '#ef4444';
                // Fallback a locale
                leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
            }
        } else {
            // Usa solo locale
            leaderboard = JSON.parse(localStorage.getItem('gridSurvivorLeaderboard') || '[]');
        }

        // Renderizza
        if (leaderboard.length === 0) {
            container.innerHTML = `<p style="padding:20px;color:#666;">${t('lbEmpty')}</p>`;
        } else {
            container.innerHTML = leaderboard.map((entry, i) => {
                let cls = 'leaderboard-entry';
                let medal = '';
                let badge = '';
                
                // Check if this is user's just-saved entry
                const isUserEntry = userScore !== null && entry.score === userScore && entry.timestamp > (Date.now() - 10000); // last 10 seconds
                
                if (i === 0) { cls += ' top1'; medal = 'ü•á '; }
                else if (i === 1) { cls += ' top2'; medal = 'ü•à '; }
                else if (i === 2) { cls += ' top3'; medal = 'ü•â '; }
                
                if (isUserEntry) {
                    cls += ' user-entry';
                    badge = ' <span class="new-badge">üÜï TU</span>';
                }
                
                // Victory trophy if completed all 49 cells
                const victoryIcon = entry.victory ? ' üèÜ' : '';

                return `<div class="${cls}">
                    <div>${medal}${entry.emoji || 'üë§'} ${i + 1}. ${entry.name}${victoryIcon}${badge}</div>
                    <div><strong>${entry.score}</strong> pts</div>
                </div>`;
            }).join('');
        }
    }

    function closeLeaderboard() {
        document.getElementById('leaderboard-overlay').classList.remove('show');
        // Non resettare il gioco: il giocatore potrebbe averlo aperto durante una partita
    }

    function confirmResetLeaderboard() {
        const confirmed = confirm('‚ö†Ô∏è ATTENZIONE!\n\nQuesto canceller√† TUTTI i punteggi dalla classifica online.\n\nSei sicuro?');
        if (confirmed) {
            const doubleCheck = confirm('Conferma di nuovo: vuoi davvero cancellare TUTTA la classifica globale?');
            if (doubleCheck) {
                resetLeaderboard();
            }
        }
    }

    async function resetLeaderboard() {
        // Reset locale
        localStorage.removeItem('gridSurvivorLeaderboard');
        
        // Reset Firebase se disponibile
        if (useOnlineLeaderboard && database) {
            try {
                await database.ref('leaderboard').remove();
                console.log('‚úÖ Online leaderboard cleared');
                alert('‚úÖ Classifica online cancellata con successo!');
            } catch (error) {
                console.error('‚ùå Failed to clear online leaderboard:', error);
                alert('‚ùå Errore: impossibile cancellare la classifica online.\nVerifica le regole Firebase.');
            }
        }

        // Aggiorna visualizzazione
        if (document.getElementById('leaderboard-overlay').classList.contains('show')) {
            showLeaderboard();
        }
    }

    function closeGameOver() {
        document.getElementById('game-over').classList.remove('show');
        resetGame();
    }

    // ‚îÄ‚îÄ‚îÄ Reset ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function resetGame() {
        clearInterval(gameState.timerInterval);

        gameState = {
            score: 0,
            cellsEliminated: 0,
            currentStreak: 0,
            bestStreak: 0,
            selectedCell: null,
            eliminatedCells: new Set(),
            timerInterval: null,
            timeRemaining: TIMER_DURATION,
            isGameActive: false,
            roundNumber: 0,
            bonusCells: new Map(),
            collectedBonuses: [],
            activeShield: false,
            doublePointsRemaining: 0,
            visionActive: false,
            safeCells: [],
            isProcessingReveal: false,
            dangerZone: { row: 0, col: 0, dir: { dr: 1, dc: 1 } },
            lifelineActive: false,
            lifelineCells: [],
            lives: 3,
            pointsStreak: 0,
            isPaused: false,
            luckyActive: false,
            malusActive: false,
            malusFound: false,
            allBonusesInGame: null,
            gameStarted: false,
            bonusHintShown: false,
            victoryAchieved: false
        };

        initGrid();
        updateStats();
        updateLives();
        updateShieldIndicator();
        updateBonusDisplay(); // Reset della visualizzazione bonus

        // Reset timer perimetrale visuale
        const svg  = document.getElementById('timer-perimeter');
        const rect = document.getElementById('timer-rect');
        rect.style.strokeDashoffset = 0;
        svg.classList.remove('warning', 'danger');

        document.getElementById('combo').textContent = '';
        updateMessage(t('msgSelectCell'), 'info');
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('reset-btn').style.display = 'inline-block';
        
        // Mantieni le traduzioni dopo il reset
        updateUIStrings();
    }

    // ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Admin reset via URL: ?admin=GRIDWIN2024
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('admin') === 'GRIDWIN2024') {
        // Crea pulsante admin reset
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'üîê ADMIN: Reset Classifica';
        adminBtn.className = 'secondary';
        adminBtn.style.position = 'fixed';
        adminBtn.style.bottom = '20px';
        adminBtn.style.right = '20px';
        adminBtn.style.zIndex = '9999';
        adminBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        adminBtn.style.color = 'white';
        adminBtn.style.border = 'none';
        adminBtn.onclick = async () => {
            if (!confirm('‚ö†Ô∏è ADMIN: Cancellare TUTTA la classifica online?')) return;
            if (!confirm('ULTIMA CONFERMA: Sei ASSOLUTAMENTE sicuro?')) return;
            
            try {
                if (useOnlineLeaderboard && database) {
                    await database.ref('leaderboard').remove();
                    alert('‚úÖ Classifica online cancellata con successo!');
                }
                localStorage.removeItem('gridSurvivorLeaderboard');
                alert('‚úÖ Classifica locale cancellata!');
                window.location.reload();
            } catch (error) {
                alert('‚ùå Errore: ' + error.message);
            }
        };
        document.body.appendChild(adminBtn);
        console.log('üîê Admin mode active');
    }
    
    initGrid();
    renderEmojiPicker();
    
    // Mostra tutorial solo la prima volta
    if (!tutorialCompleted) {
        // Mostra tutorial dopo un breve delay per permettere il rendering della UI
        setTimeout(() => showTutorial(), 500);
    }
    
    
    // Update UI with translations
    function updateUIStrings() {
        // Stats
        const statScore = document.getElementById('stat-score');
        if (statScore) statScore.textContent = t('score');
        
        const statCells = document.getElementById('stat-cells');
        if (statCells) statCells.textContent = t('cells');
        
        const statStreak = document.getElementById('stat-streak');
        if (statStreak) statStreak.textContent = t('streak');
        
        // Leaderboard buttons
        document.querySelectorAll('.i18n-lb-text').forEach(el => {
            el.textContent = t('btnLeaderboardText');
        });
        
        document.querySelectorAll('.i18n-save-text').forEach(el => {
            el.textContent = t('btnSaveLeaderboard');
        });
        
        document.querySelectorAll('.i18n-vic-text').forEach(el => {
            el.textContent = t('btnSaveLeaderboard');
        });
        
        // Translate all data-i18n elements
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (key) el.textContent = t(key);
        });
        
        // Translate placeholders
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            if (key) el.placeholder = t(key);
        });
        
        // Initial message
        const msgEl = document.getElementById('message');
        if (msgEl && msgEl.textContent.includes('Seleziona una casella')) {
            msgEl.textContent = t('msgSelectCell');
        }
    }
    
    // Helper to update bonus names in UI
    function updateBonusNamesUI() {
        // This will be called after bonus display updates
        // Bonus names are already using t() in the BONUS_TYPES definitions
    }

    // Set active language button
    document.addEventListener('DOMContentLoaded', () => {
        const langBtn = document.getElementById('lang-' + GridSurvivorI18N.currentLang);
        if (langBtn) langBtn.classList.add('active');
        
        // Also activate tutorial language buttons
        const tutLangBtn = document.getElementById('tut-lang-' + GridSurvivorI18N.currentLang);
        if (tutLangBtn) tutLangBtn.classList.add('active');
        
        // Update page title
        document.title = t('title') || document.title;
        updateUIStrings();
    });

</script>
</body>
</html>
